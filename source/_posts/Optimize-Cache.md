---
title: Optimize Cache
date: 2022-11-16 15:13:43
tags: [课程, 体系结构, 存储]
categories: [清浅录]
cover: https://cn.bing.com/th?id=OHR.YiPeng_EN-US0467115147_UHD.jpg&pid=hp&w=384&h=216&rs=1&c=4
typora-root-url: Optimize-Cache
---

# 缓存优化方案

这里总结一些现有的缓存优化方案, 当然还有很多其他的方案, 这里聚焦在我所不熟悉的部分.

## Pipelined caches

实现缓存访问的流水化, 使第一级缓存命中的实际延迟可以分散到多个时钟周期, 从而缩短时钟周期时间, 提高带宽, 但会减缓命中速度. 

## Multibanked caches

将缓存划分成几个相互独立, 支持同时访问的缓存组.

## Merging write buffers

合并写缓冲区以降低缺失代价, 因为所有存储内容都必须发送到层次结构的下一层次, 所以直写缓存依赖于写缓冲区. 如果写缓冲区为空, 则数据和整个地址被写到缓冲区中, 从处理器的角度来看, 写入操作已经完成. 如果缓冲区中包含其他经过修改的块, 则检查它们的地址, 看新数据的地址是否与写缓冲区中有效项目地址匹配. 如果匹配, 则将新数据与这个项目合并在一起, 这种优化方法成为写合并.

## Hardware Prefetching

在处理器请求项目之前, 预先提取它们. 指令和数据都可以预取. 指令预取通常在缓存外部的硬件中完成, 

## Compiler optimizations

这种技术可以在不改变任何硬件的情况下降低缺失率. 主要分成两个维度: 指令缺失性能改进和数据缺失性能改进.

1. 循环交换: 数据的连续性
2. 分块: 对于正交访问模式, 可以对子矩阵进行操作.其目的是在缓存中载入的数据被替换之前, 在最大限度上利用它. 

编译器优化还可以用来控制预取, 以降低缺失代价或缺失率

作为硬件预取的替代方案, 可以在处理器需要某一数据之前, 由编译器插入请求该数据的预取指令:

1. 寄存器预取将数据值载入到一个寄存器中
2. 缓存预取仅将数据载入到缓存中, 而不是寄存器中
