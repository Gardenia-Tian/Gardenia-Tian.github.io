[{"id":"3b2b2b9349423fdf4e4b627bcefbcbd6","title":"Reproducibility Badges","content":"Reproducibility Badges\n最近SC22正在如火如荼地进行, 作为一个科研小白, 我也有简单地远程围观这次会议. 在阅读SC会议的论文的时候, 我们会发现论文上总是有三个圆形的小标志, 所以不禁好奇这个是个什么东西, 经过一番查阅资料这里简单一下这个标志的含义.\n\n这三个标志是Reproducibility Badges, 也就是再现性徽章.\n","slug":"Reproducibility-Badges","date":"2022-11-18T06:01:56.000Z","categories_index":"清浅集","tags_index":"conference,SC","author_index":"Rui"},{"id":"ffa18e133968cd6ccc902d710772d8e1","title":"Optimize Cache","content":"缓存优化方案这里总结一些现有的缓存优化方案, 当然还有很多其他的方案, 这里聚焦在我所不熟悉的部分.\nPipelined caches实现缓存访问的流水化, 使第一级缓存命中的实际延迟可以分散到多个时钟周期, 从而缩短时钟周期时间, 提高带宽, 但会减缓命中速度. \nMultibanked caches将缓存划分成几个相互独立, 支持同时访问的缓存组.\nMerging write buffers合并写缓冲区以降低缺失代价, 因为所有存储内容都必须发送到层次结构的下一层次, 所以直写缓存依赖于写缓冲区. 如果写缓冲区为空, 则数据和整个地址被写到缓冲区中, 从处理器的角度来看, 写入操作已经完成. 如果缓冲区中包含其他经过修改的块, 则检查它们的地址, 看新数据的地址是否与写缓冲区中有效项目地址匹配. 如果匹配, 则将新数据与这个项目合并在一起, 这种优化方法成为写合并.\nHardware Prefetching在处理器请求项目之前, 预先提取它们. 指令和数据都可以预取. 指令预取通常在缓存外部的硬件中完成, \nCompiler optimizations这种技术可以在不改变任何硬件的情况下降低缺失率. 主要分成两个维度: 指令缺失性能改进和数据缺失性能改进.\n\n循环交换: 数据的连续性\n分块: 对于正交访问模式, 可以对子矩阵进行操作.其目的是在缓存中载入的数据被替换之前, 在最大限度上利用它.\n\n编译器优化还可以用来控制预取, 以降低缺失代价或缺失率\n作为硬件预取的替代方案, 可以在处理器需要某一数据之前, 由编译器插入请求该数据的预取指令:\n\n寄存器预取将数据值载入到一个寄存器中\n缓存预取仅将数据载入到缓存中, 而不是寄存器中\n\n","slug":"Optimize-Cache","date":"2022-11-16T07:13:43.000Z","categories_index":"清浅录","tags_index":"课程,体系结构,存储","author_index":"Rui"},{"id":"7bcb9e1af25ded2b038f5286bb791f16","title":"第一篇博客","content":"年轻人的第一篇博客GitHub的博客仓库很早就创立了, 但是拖了很久都没有部署. 总是因为各种原因退缩, 这次终于把界面什么的都配置了一下, 算是勉勉强强能看了, 还有很多功能还没有开发, 这些还需要日后一点一点探索, 不过有了GitHub博客也终于向一名合格的程序员迈进了一步, 希望以后能在这里记录一下自己的学习笔记, 日常心得, 生活碎片, 也希望能给浏览到博客的朋友带来一点点帮助.\n\n","slug":"启程","date":"2022-11-09T09:39:28.000Z","categories_index":"陶然集","tags_index":"随笔","author_index":"Rui"}]