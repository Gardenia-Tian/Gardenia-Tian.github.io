[{"id":"e9e2dbc3ab9cf522942297faeb7b28ca","title":"SC22:Scalable Irregular Parallelism with GPUs","content":"SC22: Scalable Irregular Parallelism with GPUs: Getting CPUs Out of the Way\n背景知识\n在开始介绍本文的内容之前, 先进行一些扫盲\n主要工作\n提出了Atos框架, 可以动态调度多节点GPU系统, 支持节点内和节点间PGAS轻量级单边内存操作\n","slug":"SC22-Scalable-Irregular-Parallelism-with-GPUs","date":"2022-11-18T11:33:47.000Z","categories_index":"知鱼集","tags_index":"conference,SC22","author_index":"Gardenia"},{"id":"3b2b2b9349423fdf4e4b627bcefbcbd6","title":"Reproducibility Badges","content":"Reproducibility Badges最近SC22正在如火如荼地进行, 作为一个科研小白, 我也有简单地远程围观这次会议. 在阅读SC会议的论文的时候, 我们会发现论文上总是有三个圆形的小标志, 所以不禁好奇这个是个什么东西, 经过一番查阅资料这里简单一下这个标志的含义.\n\n这三个标志是Reproducibility Badges, 也就是再现性徽章. ACM定义了几个再现性徽章，涵盖从轻到强的再现性参与的几个级别，\nArtifacts Evaluated此徽章适用于相关工件已成功完成独立审核的论文。此徽章不需要公开物品。然而，它们确实需要提供给审阅者。区分了两个级别，在任何情况下只能应用其中一个级别.\nArtifacts Evaluated – Functional v1.1与研究相关的人工制品被发现是有记录的、一致的、完整的、可操作的，并且包括适当的验证和确认证据.\n\nArtifacts Evaluated – Reusable v1.1与论文相关的工件的质量大大超过了最小功能。也就是说，它们具有已评估工件的所有质量——功能级别，但除此之外，它们都经过了非常仔细的记录和良好的结构，以便于重用和重新调整用途。特别是，严格遵守研究界对这类文物的规范和标准。\n\nArtifacts Available此徽章适用于相关工件已永久可供检索的论文。\nArtifacts Available v1.1作者创建的与本文相关的工件已放置在可公开访问的档案库中。提供了指向该存储库的DOI或链接以及对象的唯一标识符。\n\nResults Validated此徽章适用于作者以外的个人或团队成功获得论文主要结果的论文。区分两个级别.\nResults Reproduced v1.1\n论文的主要结果是由作者以外的个人或团队进行的后续研究，部分使用作者提供的产品。\nResults Replicated v1.1论文的主要结果是由作者以外的个人或团队在后续研究中独立获得的，没有使用作者提供的产品。\n\n","slug":"Reproducibility-Badges","date":"2022-11-18T06:01:56.000Z","categories_index":"清浅录","tags_index":"conference,SC","author_index":"Gardenia"},{"id":"ffa18e133968cd6ccc902d710772d8e1","title":"Optimize Cache","content":"缓存优化方案\n这里总结一些现有的缓存优化方案, 当然还有很多其他的方案, 这里聚焦在我所不熟悉的部分.\nPipelined caches\n实现缓存访问的流水化, 使第一级缓存命中的实际延迟可以分散到多个时钟周期, 从而缩短时钟周期时间, 提高带宽, 但会减缓命中速度.\nMultibanked caches\n将缓存划分成几个相互独立, 支持同时访问的缓存组.\nMerging write buffers\n合并写缓冲区以降低缺失代价, 因为所有存储内容都必须发送到层次结构的下一层次, 所以直写缓存依赖于写缓冲区. 如果写缓冲区为空, 则数据和整个地址被写到缓冲区中, 从处理器的角度来看, 写入操作已经完成. 如果缓冲区中包含其他经过修改的块, 则检查它们的地址, 看新数据的地址是否与写缓冲区中有效项目地址匹配. 如果匹配, 则将新数据与这个项目合并在一起, 这种优化方法成为写合并.\nHardware Prefetching\n在处理器请求项目之前, 预先提取它们. 指令和数据都可以预取. 指令预取通常在缓存外部的硬件中完成,\nCompiler optimizations\n这种技术可以在不改变任何硬件的情况下降低缺失率. 主要分成两个维度: 指令缺失性能改进和数据缺失性能改进.\n\n循环交换: 数据的连续性\n分块: 对于正交访问模式, 可以对子矩阵进行操作.其目的是在缓存中载入的数据被替换之前, 在最大限度上利用它.\n\n编译器优化还可以用来控制预取, 以降低缺失代价或缺失率\n作为硬件预取的替代方案, 可以在处理器需要某一数据之前, 由编译器插入请求该数据的预取指令:\n\n寄存器预取将数据值载入到一个寄存器中\n缓存预取仅将数据载入到缓存中, 而不是寄存器中\n\n","slug":"Optimize-Cache","date":"2022-11-16T07:13:43.000Z","categories_index":"清浅录","tags_index":"课程,体系结构,存储","author_index":"Gardenia"},{"id":"7bcb9e1af25ded2b038f5286bb791f16","title":"第一篇博客","content":"年轻人的第一篇博客\nGitHub的博客仓库很早就创立了, 但是拖了很久都没有部署. 总是因为各种原因退缩, 这次终于把界面什么的都配置了一下, 算是勉勉强强能看了, 还有很多功能还没有开发, 这些还需要日后一点一点探索, 不过有了GitHub博客也终于向一名合格的程序员迈进了一步, 希望以后能在这里记录一下自己的学习笔记, 日常心得, 生活碎片, 也希望能给浏览到博客的朋友带来一点点帮助.\n\n","slug":"启程","date":"2022-11-09T09:39:28.000Z","categories_index":"陶然集","tags_index":"随笔","author_index":"Gardenia"}]