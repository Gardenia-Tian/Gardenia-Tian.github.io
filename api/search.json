[{"id":"c1c6c992691a014e062c4081c98a903e","title":"为linux设置回收站","content":"为Linux设置回收站昨天手快误删了一个很重要的文件夹, 经过一系列的操作最后发现确实是找不回来了, 所以痛定思痛一定要为Linux搭建一个回收站, 参考了网上很多教程, 现在来记录一下搭建过程.\n原理原理其实很简单, 就是自定义一个回收站文件夹, 然后将删除指令自定义成将文件移动到回收站里, 再设置一个定时来定期清空回收站文件夹.\n操作流程创建回收站文件夹我把回收站创建在我的账号的根目录下了, 并且希望平时隐藏, 所以指令如下\nmkdir ~/.trash\n\n回收站相关的命令进行定义vim ~/.bashrc_trash\n\n创建好bashrc_trash文件之后, 在里面添加如下内容\n# 为rm重定位为trash的命令, 当执行rm的时候自动执行trash函数\nalias rm=trash\n# 同上\nalias r=trash\n# 列出回收站的内容\nalias rl='ls ~/.trash'\n# 撤销删除\nalias ur=undelfile\n\n# 撤销删除, 就是将回收站中的内容移动回去\nundelfile()\n&#123;\n mv -i ~/.trash/\\$@ ./\n&#125;\n\n# 删除, 就是将当前文件夹移到回收站里, 注意mv指令没有-r参数, 所以使用的时候不用rm -rf, 直接rm -f或者rm就可以\ntrash()\n&#123;\n mv $@ ~/.trash/\n&#125;\n\n# 清空回收站, 添加确认操作\ncleartrash()\n&#123;\n read -p \"clear sure?[n]\" confirm;\n [ $confirm == 'y' ] || [ $confirm == 'Y' ] &amp;&amp; /bin/rm -rf ~/.trash/*\n&#125;\n\n# 不需要确认的清空回收站, 用于定时清空, 事实上也可以给cleartrash()配一个参数, 这个以后要是有时间可以再搞一下\nCLEARTRASH()\n&#123;\n /bin/rm -rf ~/.trash/*\n&#125;\n\n将自定义的指令添加到.bashrcvim ~/.bashrc\n\n打开~/.bashrc之后在其中添加如下指令\n# add trash\nif [ ! -f \"~/.bashrc_trash\" ]; then\n    . ~/.bashrc_trash\nfi\n\n这样每次启动一个终端就会自动加载我们自定义的指令\n定期清空文件夹其实到上一步就已经可以使用回收站了, 但是我们希望回收站更完善一点, 能够定时清空回收站, 这样就不用我们手动管理回收站中的内容了, 所以再设置一个定时清空功能. 这个功能要用到crontab 指令, Linux crontab 是用来定期执行程序的命令, -e参数可以执行文字编辑器来设定时程表。首先输入如下指令\ncrontab -e\n\n 之后会进入到&#x2F;tmp&#x2F;crontab.xFcuCa&#x2F;crontab, 这个如果不指定用户默认是为自己的用户配置的.\n之后在里面添加\n0 0 * * 0 CLEARTRASH\n\n这句话的含义是每周日零点清空回收站, 前面的五位数字用来指定时间, 含义如下\n*    *    *    *    *\n-    -    -    -    -\n|    |    |    |    |\n|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)\n|    |    |    +---------- 月份 (1 - 12) \n|    |    +--------------- 一个月中的第几天 (1 - 31)\n|    +-------------------- 小时 (0 - 23)\n+------------------------- 分钟 (0 - 59)\n\n那么到此位置我们回收站的配置就完成了, 其实还有更好的方式, 可以让回收站定期清空指定日期以前的数据, 这样安全性会更好一点, 如果以后有时间, 我们就再折腾一下那个方案, 现在的版本也可以实现一个较为安全的rm操作, 妈妈再也不用担心我手快啦!\n","slug":"为linux设置回收站","date":"2022-11-21T03:12:03.000Z","categories_index":"清浅录","tags_index":"Linux,系统管理","author_index":"Gardenia"},{"id":"0f7d08163e7123e37a424c72e1969a8c","title":"RDMA技术解读","content":"RDMA技术解读本文参考技术蛋老师讲解RDMA的视频, It_server技术分享的视频侵删\n传统Socket通信\n用户将应用发送出去, 需要先到操作系统内核, 再到网络接口, 然后在接收方收到信息再次经过操作系统内核, 并在用户态分析数据.\nRDMA通信模式\n绕过内核态, 直接发送数据给硬件. 可以满足高带宽, 低延迟, 低CPU消耗的需求.\nRDMA可以释放CPU的负载, 减少数据拷贝, 内存访问, 实现零拷贝和内核旁路.\n\n零拷贝:应用程序能够直接执行数据传输, 无需涉及到网络软件栈的情况下, 数据能够被直接发送到缓冲区或者能够直接从缓冲区里被接收\n内核旁路: 应用程序可以直接在用户态执行数据传输, 不需要在内核态与用户态之间做上下文切换\n\nIBRDMA的原生网络协议, 通过专用硬件实现最优的性能, 但是由于专用硬件的原因, InifiniBand要求从L到L4 需要使用自己专用的硬件, 设备成本非常高\nRoCERDMA跑在以太网上的一种网络, RoCE v1还没有摆脱Infiniband的束缚, RoCE v2使用UDP+IP, 既可以使用以太网交换机, 可以兼容现有以太网, IP协议使得数据可以被路由.\n\niWARP可以更大规模的部署和组网, iWARP是基于TCP的, 传统的iWARP厂商实现时需要兼容的完整的协议栈, 设计和实现成本很高, 不需要交换机支持无损以太网传输, 虽然适用于当前的互联网传输, 但是性能比RoCE要差.\n\n","slug":"RDMA技术解读","date":"2022-11-18T13:11:09.000Z","categories_index":"清浅录","tags_index":"体系结构,网络","author_index":"Gardenia"},{"id":"3b2b2b9349423fdf4e4b627bcefbcbd6","title":"Reproducibility Badges","content":"Reproducibility Badges最近SC22正在如火如荼地进行, 作为一个科研小白, 我也有简单地远程围观这次会议. 在阅读SC会议的论文的时候, 我们会发现论文上总是有三个圆形的小标志, 所以不禁好奇这个是个什么东西, 经过一番查阅资料这里简单一下这个标志的含义.\n\n这三个标志是Reproducibility Badges, 也就是再现性徽章. ACM定义了几个再现性徽章，涵盖从轻到强的再现性参与的几个级别，\nArtifacts Evaluated此徽章适用于相关工件已成功完成独立审核的论文。此徽章不需要公开物品。然而，它们确实需要提供给审阅者。区分了两个级别，在任何情况下只能应用其中一个级别.\nArtifacts Evaluated – Functional v1.1与研究相关的人工制品被发现是有记录的、一致的、完整的、可操作的，并且包括适当的验证和确认证据.\n\nArtifacts Evaluated – Reusable v1.1与论文相关的工件的质量大大超过了最小功能。也就是说，它们具有已评估工件的所有质量——功能级别，但除此之外，它们都经过了非常仔细的记录和良好的结构，以便于重用和重新调整用途。特别是，严格遵守研究界对这类文物的规范和标准。\n\nArtifacts Available此徽章适用于相关工件已永久可供检索的论文。\nArtifacts Available v1.1作者创建的与本文相关的工件已放置在可公开访问的档案库中。提供了指向该存储库的DOI或链接以及对象的唯一标识符。\n\nResults Validated此徽章适用于作者以外的个人或团队成功获得论文主要结果的论文。区分两个级别.\nResults Reproduced v1.1\n论文的主要结果是由作者以外的个人或团队进行的后续研究，部分使用作者提供的产品。\nResults Replicated v1.1论文的主要结果是由作者以外的个人或团队在后续研究中独立获得的，没有使用作者提供的产品。\n\n","slug":"Reproducibility-Badges","date":"2022-11-18T06:01:56.000Z","categories_index":"清浅录","tags_index":"conference,SC","author_index":"Gardenia"},{"id":"ffa18e133968cd6ccc902d710772d8e1","title":"Optimize Cache","content":"缓存优化方案\n这里总结一些现有的缓存优化方案, 当然还有很多其他的方案, 这里聚焦在我所不熟悉的部分.\nPipelined caches\n实现缓存访问的流水化, 使第一级缓存命中的实际延迟可以分散到多个时钟周期, 从而缩短时钟周期时间, 提高带宽, 但会减缓命中速度.\nMultibanked caches\n将缓存划分成几个相互独立, 支持同时访问的缓存组.\nMerging write buffers\n合并写缓冲区以降低缺失代价, 因为所有存储内容都必须发送到层次结构的下一层次, 所以直写缓存依赖于写缓冲区. 如果写缓冲区为空, 则数据和整个地址被写到缓冲区中, 从处理器的角度来看, 写入操作已经完成. 如果缓冲区中包含其他经过修改的块, 则检查它们的地址, 看新数据的地址是否与写缓冲区中有效项目地址匹配. 如果匹配, 则将新数据与这个项目合并在一起, 这种优化方法成为写合并.\nHardware Prefetching\n在处理器请求项目之前, 预先提取它们. 指令和数据都可以预取. 指令预取通常在缓存外部的硬件中完成,\nCompiler optimizations\n这种技术可以在不改变任何硬件的情况下降低缺失率. 主要分成两个维度: 指令缺失性能改进和数据缺失性能改进.\n\n循环交换: 数据的连续性\n分块: 对于正交访问模式, 可以对子矩阵进行操作.其目的是在缓存中载入的数据被替换之前, 在最大限度上利用它.\n\n编译器优化还可以用来控制预取, 以降低缺失代价或缺失率\n作为硬件预取的替代方案, 可以在处理器需要某一数据之前, 由编译器插入请求该数据的预取指令:\n\n寄存器预取将数据值载入到一个寄存器中\n缓存预取仅将数据载入到缓存中, 而不是寄存器中\n\n","slug":"Optimize-Cache","date":"2022-11-16T07:13:43.000Z","categories_index":"清浅录","tags_index":"课程,体系结构,存储","author_index":"Gardenia"},{"id":"7bcb9e1af25ded2b038f5286bb791f16","title":"第一篇博客","content":"年轻人的第一篇博客\nGitHub的博客仓库很早就创立了, 但是拖了很久都没有部署. 总是因为各种原因退缩, 这次终于把界面什么的都配置了一下, 算是勉勉强强能看了, 还有很多功能还没有开发, 这些还需要日后一点一点探索, 不过有了GitHub博客也终于向一名合格的程序员迈进了一步, 希望以后能在这里记录一下自己的学习笔记, 日常心得, 生活碎片, 也希望能给浏览到博客的朋友带来一点点帮助.\n\n","slug":"启程","date":"2022-11-09T09:39:28.000Z","categories_index":"陶然集","tags_index":"随笔","author_index":"Gardenia"}]