<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Optimize Cache</title>
    <url>//post/Optimize-Cache.html</url>
    <content><![CDATA[<h1>缓存优化方案</h1>
<p>这里总结一些现有的缓存优化方案, 当然还有很多其他的方案, 这里聚焦在我所不熟悉的部分.</p>
<h2 id="pipelined-caches">Pipelined caches</h2>
<p>实现缓存访问的流水化, 使第一级缓存命中的实际延迟可以分散到多个时钟周期, 从而缩短时钟周期时间, 提高带宽, 但会减缓命中速度.</p>
<h2 id="multibanked-caches">Multibanked caches</h2>
<p>将缓存划分成几个相互独立, 支持同时访问的缓存组.</p>
<h2 id="merging-write-buffers">Merging write buffers</h2>
<p>合并写缓冲区以降低缺失代价, 因为所有存储内容都必须发送到层次结构的下一层次, 所以直写缓存依赖于写缓冲区. 如果写缓冲区为空, 则数据和整个地址被写到缓冲区中, 从处理器的角度来看, 写入操作已经完成. 如果缓冲区中包含其他经过修改的块, 则检查它们的地址, 看新数据的地址是否与写缓冲区中有效项目地址匹配. 如果匹配, 则将新数据与这个项目合并在一起, 这种优化方法成为写合并.</p>
<h2 id="hardware-prefetching">Hardware Prefetching</h2>
<p>在处理器请求项目之前, 预先提取它们. 指令和数据都可以预取. 指令预取通常在缓存外部的硬件中完成,</p>
<h2 id="compiler-optimizations">Compiler optimizations</h2>
<p>这种技术可以在不改变任何硬件的情况下降低缺失率. 主要分成两个维度: 指令缺失性能改进和数据缺失性能改进.</p>
<ol>
<li>循环交换: 数据的连续性</li>
<li>分块: 对于正交访问模式, 可以对子矩阵进行操作.其目的是在缓存中载入的数据被替换之前, 在最大限度上利用它.</li>
</ol>
<p>编译器优化还可以用来控制预取, 以降低缺失代价或缺失率</p>
<p>作为硬件预取的替代方案, 可以在处理器需要某一数据之前, 由编译器插入请求该数据的预取指令:</p>
<ol>
<li>寄存器预取将数据值载入到一个寄存器中</li>
<li>缓存预取仅将数据载入到缓存中, 而不是寄存器中</li>
</ol>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>体系结构</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>//post/%E5%90%AF%E7%A8%8B.html</url>
    <content><![CDATA[<h1>年轻人的第一篇博客</h1>
<p>GitHub的博客仓库很早就创立了, 但是拖了很久都没有部署. 总是因为各种原因退缩, 这次终于把界面什么的都配置了一下, 算是勉勉强强能看了, 还有很多功能还没有开发, 这些还需要日后一点一点探索, 不过有了GitHub博客也终于向一名合格的程序员迈进了一步, 希望以后能在这里记录一下自己的学习笔记, 日常心得, 生活碎片, 也希望能给浏览到博客的朋友带来一点点帮助.</p>
<p><img src="/post/1.jpg" alt></p>
]]></content>
      <categories>
        <category>陶然集</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Reproducibility Badges</title>
    <url>//post/Reproducibility-Badges.html</url>
    <content><![CDATA[<h1 id="Reproducibility-Badges"><a href="#Reproducibility-Badges" class="headerlink" title="Reproducibility Badges"></a>Reproducibility Badges</h1><p>最近SC22正在如火如荼地进行, 作为一个科研小白, 我也有简单地远程围观这次会议. 在阅读SC会议的论文的时候, 我们会发现论文上总是有三个圆形的小标志, 所以不禁好奇这个是个什么东西, 经过一番查阅资料这里简单一下这个标志的含义.</p>
<p><img src="/post/Reproducibility-Badges/1.png"></p>
<p>这三个标志是Reproducibility Badges, 也就是再现性徽章. ACM定义了几个再现性徽章，涵盖从轻到强的再现性参与的几个级别，</p>
<h2 id="Artifacts-Evaluated"><a href="#Artifacts-Evaluated" class="headerlink" title="Artifacts Evaluated"></a>Artifacts Evaluated</h2><p>此徽章适用于相关工件已成功完成独立审核的论文。此徽章不需要公开物品。然而，它们确实需要提供给审阅者。区分了两个级别，在任何情况下只能应用其中一个级别.</p>
<h3 id="Artifacts-Evaluated-–-Functional-v1-1"><a href="#Artifacts-Evaluated-–-Functional-v1-1" class="headerlink" title="Artifacts Evaluated – Functional v1.1"></a>Artifacts Evaluated – Functional v1.1</h3><p>与研究相关的人工制品被发现是有记录的、一致的、完整的、可操作的，并且包括适当的验证和确认证据.</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_evaluated_functional_v1_1.png" alt="img"></p>
<h3 id="Artifacts-Evaluated-–-Reusable-v1-1"><a href="#Artifacts-Evaluated-–-Reusable-v1-1" class="headerlink" title="Artifacts Evaluated – Reusable v1.1"></a>Artifacts Evaluated – Reusable v1.1</h3><p>与论文相关的工件的质量大大超过了最小功能。也就是说，它们具有已评估工件的所有质量——功能级别，但除此之外，它们都经过了非常仔细的记录和良好的结构，以便于重用和重新调整用途。特别是，严格遵守研究界对这类文物的规范和标准。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_evaluated_reusable_v1_1.png" alt="img"></p>
<h2 id="Artifacts-Available"><a href="#Artifacts-Available" class="headerlink" title="Artifacts Available"></a>Artifacts Available</h2><p>此徽章适用于相关工件已永久可供检索的论文。</p>
<h3 id="Artifacts-Available-v1-1"><a href="#Artifacts-Available-v1-1" class="headerlink" title="Artifacts Available v1.1"></a>Artifacts Available v1.1</h3><p>作者创建的与本文相关的工件已放置在可公开访问的档案库中。提供了指向该存储库的DOI或链接以及对象的唯一标识符。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_available_v1_1.png" alt="img"></p>
<h2 id="Results-Validated"><a href="#Results-Validated" class="headerlink" title="Results Validated"></a>Results Validated</h2><p>此徽章适用于作者以外的个人或团队成功获得论文主要结果的论文。区分两个级别.</p>
<h3 id="Results-Reproduced-v1-1"><a href="#Results-Reproduced-v1-1" class="headerlink" title="Results Reproduced v1.1"></a>Results Reproduced v1.1</h3><p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/results_reproduced_v1_1.png" alt="img"></p>
<p>论文的主要结果是由作者以外的个人或团队进行的后续研究，部分使用作者提供的产品。</p>
<h3 id="Results-Replicated-v1-1"><a href="#Results-Replicated-v1-1" class="headerlink" title="Results Replicated v1.1"></a>Results Replicated v1.1</h3><p>论文的主要结果是由作者以外的个人或团队在后续研究中独立获得的，没有使用作者提供的产品。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/results_replicated_v1_1.png" alt="img"></p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>conference</tag>
        <tag>SC</tag>
      </tags>
  </entry>
  <entry>
    <title>SC22:Scalable Irregular Parallelism with GPUs</title>
    <url>//post/SC22-Scalable-Irregular-Parallelism-with-GPUs.html</url>
    <content><![CDATA[<h1 id="SC22-Scalable-Irregular-Parallelism-with-GPUs-Getting-CPUs-Out-of-the-Way"><a href="#SC22-Scalable-Irregular-Parallelism-with-GPUs-Getting-CPUs-Out-of-the-Way" class="headerlink" title="SC22: Scalable Irregular Parallelism with GPUs: Getting CPUs Out of the Way"></a>SC22: Scalable Irregular Parallelism with GPUs: Getting CPUs Out of the Way</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>在开始介绍本文的内容之前, 先进行一些扫盲, 介绍一下PGAS和单边内存操作</p>
<h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><p>提出了Atos框架, 可以动态调度多节点GPU系统, 支持节点内和节点间PGAS轻量级单边内存操作</p>
]]></content>
      <categories>
        <category>知鱼集</category>
      </categories>
      <tags>
        <tag>conference</tag>
        <tag>SC22</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA技术解读</title>
    <url>//post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB.html</url>
    <content><![CDATA[<h1 id="RDMA技术解读"><a href="#RDMA技术解读" class="headerlink" title="RDMA技术解读"></a>RDMA技术解读</h1><p>本文参考<a href="%5B%E6%8F%AD%E7%A7%98%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84%E2%80%9C%E7%88%B1%E9%A9%AC%E4%BB%95%E2%80%9D%EF%BC%8C12%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82RDMA_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1ZY4y1L7Xq/?spm_id_from=333.337.search-card.all.click&vd_source=aad0e5152e96b4bf095d0017d639153b)">技术蛋老师讲解RDMA的视频</a>, <a href="%5B%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB%EF%BC%9A%E6%B5%85%E8%B0%88RDMA%E6%8A%80%E6%9C%AF_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1QL411G7wo/?spm_id_from=333.337.search-card.all.click&vd_source=aad0e5152e96b4bf095d0017d639153b)">It_server技术分享的视频</a>侵删</p>
<h2 id="传统Socket通信"><a href="#传统Socket通信" class="headerlink" title="传统Socket通信"></a>传统Socket通信</h2><p><img src="/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118211738044.png" alt="image-20221118211738044"></p>
<p>用户将应用发送出去, 需要先到操作系统内核, 再到网络接口, 然后在接收方收到信息再次经过操作系统内核, 并在用户态分析数据.</p>
<h2 id="RDMA通信模式"><a href="#RDMA通信模式" class="headerlink" title="RDMA通信模式"></a>RDMA通信模式</h2><p><img src="/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118211907180.png" alt="image-20221118211907180"></p>
<p>绕过内核态, 直接发送数据给硬件. 可以满足高带宽, 低延迟, 低CPU消耗的需求.</p>
<p>RDMA可以释放CPU的负载, 减少数据拷贝, 内存访问, 实现零拷贝和内核旁路.</p>
<ul>
<li>零拷贝:应用程序能够直接执行数据传输, 无需涉及到网络软件栈的情况下, 数据能够被直接发送到缓冲区或者能够直接从缓冲区里被接收</li>
<li>内核旁路: 应用程序可以直接在用户态执行数据传输, 不需要在内核态与用户态之间做上下文切换</li>
</ul>
<h3 id="IB"><a href="#IB" class="headerlink" title="IB"></a>IB</h3><p>RDMA的原生网络协议, 通过专用硬件实现最优的性能, 但是由于专用硬件的原因, InifiniBand要求从L到L4 需要使用自己专用的硬件, 设备成本非常高</p>
<h3 id="RoCE"><a href="#RoCE" class="headerlink" title="RoCE"></a>RoCE</h3><p>RDMA跑在以太网上的一种网络, RoCE v1还没有摆脱Infiniband的束缚, RoCE v2使用UDP+IP, 既可以使用以太网交换机, 可以兼容现有以太网, IP协议使得数据可以被路由.</p>
<p><img src="/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118212411801.png" alt="image-20221118212411801"></p>
<h3 id="iWARP"><a href="#iWARP" class="headerlink" title="iWARP"></a>iWARP</h3><p>可以更大规模的部署和组网, iWARP是基于TCP的, 传统的iWARP厂商实现时需要兼容的完整的协议栈, 设计和实现成本很高, 不需要交换机支持无损以太网传输, 虽然适用于当前的互联网传输, 但是性能比RoCE要差.</p>
<p><img src="https://img-blog.csdnimg.cn/1b2704ac4511494e8c4c1348d7ad4529.png" alt="img"></p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>网络</tag>
      </tags>
  </entry>
</search>
