<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Optimize Cache</title>
    <url>//post/Optimize-Cache.html</url>
    <content><![CDATA[<h1>缓存优化方案</h1>
<p>这里总结一些现有的缓存优化方案, 当然还有很多其他的方案, 这里聚焦在我所不熟悉的部分.</p>
<h2 id="pipelined-caches">Pipelined caches</h2>
<p>实现缓存访问的流水化, 使第一级缓存命中的实际延迟可以分散到多个时钟周期, 从而缩短时钟周期时间, 提高带宽, 但会减缓命中速度.</p>
<h2 id="multibanked-caches">Multibanked caches</h2>
<p>将缓存划分成几个相互独立, 支持同时访问的缓存组.</p>
<h2 id="merging-write-buffers">Merging write buffers</h2>
<p>合并写缓冲区以降低缺失代价, 因为所有存储内容都必须发送到层次结构的下一层次, 所以直写缓存依赖于写缓冲区. 如果写缓冲区为空, 则数据和整个地址被写到缓冲区中, 从处理器的角度来看, 写入操作已经完成. 如果缓冲区中包含其他经过修改的块, 则检查它们的地址, 看新数据的地址是否与写缓冲区中有效项目地址匹配. 如果匹配, 则将新数据与这个项目合并在一起, 这种优化方法成为写合并.</p>
<h2 id="hardware-prefetching">Hardware Prefetching</h2>
<p>在处理器请求项目之前, 预先提取它们. 指令和数据都可以预取. 指令预取通常在缓存外部的硬件中完成,</p>
<h2 id="compiler-optimizations">Compiler optimizations</h2>
<p>这种技术可以在不改变任何硬件的情况下降低缺失率. 主要分成两个维度: 指令缺失性能改进和数据缺失性能改进.</p>
<ol>
<li>循环交换: 数据的连续性</li>
<li>分块: 对于正交访问模式, 可以对子矩阵进行操作.其目的是在缓存中载入的数据被替换之前, 在最大限度上利用它.</li>
</ol>
<p>编译器优化还可以用来控制预取, 以降低缺失代价或缺失率</p>
<p>作为硬件预取的替代方案, 可以在处理器需要某一数据之前, 由编译器插入请求该数据的预取指令:</p>
<ol>
<li>寄存器预取将数据值载入到一个寄存器中</li>
<li>缓存预取仅将数据载入到缓存中, 而不是寄存器中</li>
</ol>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>体系结构</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>//post/%E5%90%AF%E7%A8%8B.html</url>
    <content><![CDATA[<h1>年轻人的第一篇博客</h1>
<p>GitHub的博客仓库很早就创立了, 但是拖了很久都没有部署. 总是因为各种原因退缩, 这次终于把界面什么的都配置了一下, 算是勉勉强强能看了, 还有很多功能还没有开发, 这些还需要日后一点一点探索, 不过有了GitHub博客也终于向一名合格的程序员迈进了一步, 希望以后能在这里记录一下自己的学习笔记, 日常心得, 生活碎片, 也希望能给浏览到博客的朋友带来一点点帮助.</p>
<p><img src="/post/1.jpg" alt></p>
]]></content>
      <categories>
        <category>陶然集</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Reproducibility Badges</title>
    <url>//post/Reproducibility-Badges.html</url>
    <content><![CDATA[<h1 id="Reproducibility-Badges"><a href="#Reproducibility-Badges" class="headerlink" title="Reproducibility Badges"></a>Reproducibility Badges</h1><p>最近SC22正在如火如荼地进行, 作为一个科研小白, 我也有简单地远程围观这次会议. 在阅读SC会议的论文的时候, 我们会发现论文上总是有三个圆形的小标志, 所以不禁好奇这个是个什么东西, 经过一番查阅资料这里简单一下这个标志的含义.</p>
<p><img src="/post/Reproducibility-Badges/1.png"></p>
<p>这三个标志是Reproducibility Badges, 也就是再现性徽章. ACM定义了几个再现性徽章，涵盖从轻到强的再现性参与的几个级别，</p>
<h2 id="Artifacts-Evaluated"><a href="#Artifacts-Evaluated" class="headerlink" title="Artifacts Evaluated"></a>Artifacts Evaluated</h2><p>此徽章适用于相关工件已成功完成独立审核的论文。此徽章不需要公开物品。然而，它们确实需要提供给审阅者。区分了两个级别，在任何情况下只能应用其中一个级别.</p>
<h3 id="Artifacts-Evaluated-–-Functional-v1-1"><a href="#Artifacts-Evaluated-–-Functional-v1-1" class="headerlink" title="Artifacts Evaluated – Functional v1.1"></a>Artifacts Evaluated – Functional v1.1</h3><p>与研究相关的人工制品被发现是有记录的、一致的、完整的、可操作的，并且包括适当的验证和确认证据.</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_evaluated_functional_v1_1.png" alt="img"></p>
<h3 id="Artifacts-Evaluated-–-Reusable-v1-1"><a href="#Artifacts-Evaluated-–-Reusable-v1-1" class="headerlink" title="Artifacts Evaluated – Reusable v1.1"></a>Artifacts Evaluated – Reusable v1.1</h3><p>与论文相关的工件的质量大大超过了最小功能。也就是说，它们具有已评估工件的所有质量——功能级别，但除此之外，它们都经过了非常仔细的记录和良好的结构，以便于重用和重新调整用途。特别是，严格遵守研究界对这类文物的规范和标准。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_evaluated_reusable_v1_1.png" alt="img"></p>
<h2 id="Artifacts-Available"><a href="#Artifacts-Available" class="headerlink" title="Artifacts Available"></a>Artifacts Available</h2><p>此徽章适用于相关工件已永久可供检索的论文。</p>
<h3 id="Artifacts-Available-v1-1"><a href="#Artifacts-Available-v1-1" class="headerlink" title="Artifacts Available v1.1"></a>Artifacts Available v1.1</h3><p>作者创建的与本文相关的工件已放置在可公开访问的档案库中。提供了指向该存储库的DOI或链接以及对象的唯一标识符。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_available_v1_1.png" alt="img"></p>
<h2 id="Results-Validated"><a href="#Results-Validated" class="headerlink" title="Results Validated"></a>Results Validated</h2><p>此徽章适用于作者以外的个人或团队成功获得论文主要结果的论文。区分两个级别.</p>
<h3 id="Results-Reproduced-v1-1"><a href="#Results-Reproduced-v1-1" class="headerlink" title="Results Reproduced v1.1"></a>Results Reproduced v1.1</h3><p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/results_reproduced_v1_1.png" alt="img"></p>
<p>论文的主要结果是由作者以外的个人或团队进行的后续研究，部分使用作者提供的产品。</p>
<h3 id="Results-Replicated-v1-1"><a href="#Results-Replicated-v1-1" class="headerlink" title="Results Replicated v1.1"></a>Results Replicated v1.1</h3><p>论文的主要结果是由作者以外的个人或团队在后续研究中独立获得的，没有使用作者提供的产品。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/results_replicated_v1_1.png" alt="img"></p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>conference</tag>
        <tag>SC</tag>
      </tags>
  </entry>
  <entry>
    <title>SC22:Scalable Irregular Parallelism with GPUs</title>
    <url>//post/SC22-Scalable-Irregular-Parallelism-with-GPUs.html</url>
    <content><![CDATA[<h1 id="SC22-Scalable-Irregular-Parallelism-with-GPUs-Getting-CPUs-Out-of-the-Way"><a href="#SC22-Scalable-Irregular-Parallelism-with-GPUs-Getting-CPUs-Out-of-the-Way" class="headerlink" title="SC22: Scalable Irregular Parallelism with GPUs: Getting CPUs Out of the Way"></a>SC22: Scalable Irregular Parallelism with GPUs: Getting CPUs Out of the Way</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>在开始介绍本文的内容之前, 先进行一些扫盲, 介绍一下PGAS和单边内存操作</p>
<h3 id="PGAS"><a href="#PGAS" class="headerlink" title="PGAS"></a>PGAS</h3><p>Partitioned Global Address Space (PGAS)</p>
<p>共享内存模型扩展性差, 消息通信模型可编程性差, 有没有一个模型能在两者之间做出一个权衡? PGAS可以. PGAS是共享内存模型, 但是共享内存对线程具有亲和性.</p>
<p><img src="/SC22-Scalable-Irregular-Parallelism-with-GPUs/image-20221119155749599.png" alt="image-20221119155749599"></p>
<p>在分布式CPU系统上，从内存模型的角度来看，PGAS模型允许用户直接访问跨节点的共享内存的联合。用户可以访问全局指针和分布式数组，并将它们连接到单个分布式数据结构中。从编程模型的角度来看，PGAS语言使用SPMD方法，其中一组固定的进程在计算开始时一起开始，在计算结束时一起结束。</p>
<h3 id="One-sides-memory-operation"><a href="#One-sides-memory-operation" class="headerlink" title="One-sides memory operation"></a>One-sides memory operation</h3><h4 id="One-sides-communication"><a href="#One-sides-communication" class="headerlink" title="One-sides communication"></a>One-sides communication</h4><p>先来看一下单边通信. 用MPI在RMA中的运行模式为例, 传统的MPI通信方式是MPI_Send和MPI_Recv, 这种模式也被称为双边通信：两个进程隐式地彼此同步。发送方和接收方都是通信的参与者, Send和Recv必须要相互匹配, 这种模式可能会造成通信的死锁或者性能下降. 在RMA的支持下, MPI提供了执行远程内存访问（RMA）的例程，也称为单边通信．其中进程可以访问其他进程上的数据，只要它在特殊的内存窗口中可用。本内容参考<a href="https://enccs.github.io/intermediate-mpi/one-sided-concepts/">One-sided communication: concepts — Intermediate MPI (enccs.github.io)</a></p>
<p>在并行框架或并行变成模型中, 各个进程之间是相互协作的, 每个worker或者每个process运行一部分的工作, 他们之间需要协调, 这就要用通信机制来完成. 通信的机制可以分成两种, <code>Cooperative</code>和<code>One sided</code>.</p>
<ul>
<li><p>Cooperative: 所有的参与者同同意并了解数据的传输</p>
<p><img src="/SC22-Scalable-Irregular-Parallelism-with-GPUs/image-20221119103705866.png" alt="image-20221119103705866"></p>
</li>
<li><p>One-sided: 只有一个worker或process传输数据. 并行进程之间的单边操作包括远程内存读取和写入。优点是可以访问数据而无需等待另一个进程</p>
<p><img src="/SC22-Scalable-Irregular-Parallelism-with-GPUs/image-20221119103756683.png" alt="image-20221119103756683"></p>
</li>
</ul>
<h4 id="one-sides-memory-operation"><a href="#one-sides-memory-operation" class="headerlink" title="one-sides memory operation"></a>one-sides memory operation</h4><p>单边内存操作和单边通信是很类似的, 只不过从消息的收发变成了对内存的操作.</p>
<h2 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h2><p>提出了Atos框架, 可以动态调度多节点GPU系统, 支持节点内和节点间PGAS轻量级单边内存操作, 用于在集群中的多个GPU之间进行异步执行。</p>
<ol>
<li><p>虽然直接从GPU到GPU的数据移动现在在现代系统上很普遍，但通信控制路径(包括通信准备和触发，可能的匹配和同步)即使在今天也通常在CPU上运行。本工作将通信控制路径移动到GPU, 并通过利用NVIDIA基于OpenSHMEM的NVSHMEM实现GPU之间真实的单边通信，该NVSHMEM将GPU内存映射到NIC(反之亦然)，以便远程GPU线程可以直接访问GPU内存，而无需本地或远程CPU参与。</p>
</li>
<li><p>传统上，在通信之前确保数据一致性是通过同步来自CPU的CUDA内核来实现的。这隐式地将数据一致性与同步结合在一起。为了避免这种耦合和由此产生的开销，ATOS实现了异步分布式队列，以确保数据一致性，并支持单边内核通信，而不需要任何同步。</p>
</li>
<li><p>传统上，只有在同步CUDA计算内核之后才会进行通信。</p>
<ul>
<li>大的,高GPU占用率的核函数的消息通信很延迟, 并且通信和计算的重叠很小</li>
<li>小的,低GPU占用率的核函数的消息通信更加频繁, 并且通信和计算的重复比较大</li>
</ul>
<p>ATOS通过从核函数内部启用细粒度轻量级的通信, 实现更多的通信和计算的重叠. 小的通信更适合我们找到足够的计算来隐藏延迟.</p>
</li>
<li><p>在没有显式同步的情况下启用通信可以部署无同步算法，由于降低了同步成本，因此具有潜在的性能优势。相比之下，GPU上的传统BSP方法排除了使用无同步算法的可能性。</p>
</li>
<li><p>最后，我们的方法足够健壮，无需更改即可在具有两个不同互连族NVLink和InfiniBand(IB)的多GPU系统上高效工作。</p>
</li>
</ol>
<p>本工作在NVlink和IB上都进行了测试, 结果表明, 使用NVLink互连，我们表明，我们的BFS和PageRank实现中的细粒度单边通信比其他框架具有更好的性能和可扩展性，因为它具有更好的延迟隐藏和更好的网络利用率。InfiniBand处理小消息的效率低于NVLink。为了优化InfiniBand的通信，ATOS实现了一个与应用程序代码并行运行的通信聚合器，它透明地将消息聚合在一起，并将它们以更大的消息包形式发送出去。我们表明，该聚合器有效地解决了由于细粒度的单边通信而导致的IB系统的带宽利用率不足的问题。在基于IB的系统上，我们的ATOS、BFS和PageRank实现在运行时和可伸缩性方面也优于其他框架。</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><ul>
<li><p>批量同步通信模型(The bulk-synchronous communication model)是分布式CPU计算中最流行的模型之一. 通过将应用划分为大量的通信和计算阶段，批量同步并行(The bulk-synchronous communication model, BSP)模型生成了与现代节点间通信网络非常匹配的通信模式，现代节点间通信网络需要大量消息来实现峰值通信带宽。</p>
</li>
<li><p>许多分区全局地址空间(Partitioned Global Address Space, PGAS)语言(如UPC、UPC++和OpenSHMEM)的分布式实现成功地采用了另一种通信模型：发出许多独立的小型通信消息的模型. 在可以同时调度独立计算和通信的应用程序中，这种模式允许这些应用程序将通信延迟与计算时间重叠。小型单边通信消除了远程处理器同步的需要，从而降低了总体同步开销。与许多批量同步程序中变化较大的网络使用相比，小型通信通常可以均匀地分布在程序的运行时，从而平滑了网络使用。这些好处对于动态的、不规则的应用程序尤其显著，这些应用程序通常在不可预测的时间内进行细粒度的通信，并且没有预先确定的模式。</p>
</li>
<li><p>PGAS很适合这种动态的不规则的通信方式, 小粒度通信的主要缺点是带宽利用率较低，但尽管如此，有研究成果表明，即使在互连带宽有限的应用中，该通信模型也可以提供显著的性能优势。</p>
</li>
<li><p>PGAS在CPU上虽然用的挺多的, 但是在GPU上不是很常用, 因为</p>
<ul>
<li>在历史上，分布式系统中的其他GPU不能直接访问GPU内存。这排除了高效、细粒度的GPU到GPU的异步通信，因为这些通信必须通过CPU进行路由，从而增加了延迟。</li>
<li>传统上, GPU的通信发生在核函数的前后, 如果放松这个限制会使数据一致性变得非常复杂, 单个大的核函数不能实现大量的overlap, 因为这样通信就变得更加的粗粒度, 而运行很多小的核函数通常会导致显著的内核启动开销和低GPU利用率.</li>
<li>许多分布式算法中最流行的方式使用BSP模型, 这些模型对单边通信不能很好的映射.</li>
</ul>
<p>因此，分布式系统上的GPU主要以批量同步的方式用于计算和通信。然而，类似于PGAS的编程模型可能是一个更好的替代方案，特别是对于非常规应用程序：具有不同的通信和同步模式的应用程序。</p>
</li>
</ul>
<h2 id="GPU上的PGAS编程模型"><a href="#GPU上的PGAS编程模型" class="headerlink" title="GPU上的PGAS编程模型"></a>GPU上的PGAS编程模型</h2><p>PGA编程模型以隐式通信(指针和数组引用)和显式的PUT和GET调用形式的单边通信原语为特色。这种方法非常适合现代的GPU到GPU通信机制，例如单个节点内的NVLink或PCIe。最近的进步使独立节点中的GPU能够直接执行进出InfiniBand网络的单边内存操作。PGAS和GPU都使用宽松的内存模型，该模型自动统一了排序、同步和原子操作的保证。</p>
<p>以前也有一些这样的多GPU框架, 将GPU视为CPU的一个进程例如，Galois、PTASK和StarPU. 在这些框架中，每个GPU内核收集内核期间生成的所有通信，并在内核结束时批量发布, 这就导致必须在下述情况中做出一个权衡: 高GPU利用率但高延迟通信，或者低GPU利用率和低延迟通信。</p>
<p>另一种选择是将每个GPU线程视为CPU进程的模拟，并允许每个GPU线程独立发出通信请求。但是, 一个GPU线程的粒度太细了, 协调数十万个并发线程的GPU任务是十分困难的. </p>
<p>需求: 能够指定一组合适大小的线程, 作为指定的worker, 这一组线程之间的集体加载&#x2F;存储可以作为充分利用GPU存储器系统所必需的合并访问来发布。</p>
<h2 id="Atos的设计模式"><a href="#Atos的设计模式" class="headerlink" title="Atos的设计模式"></a>Atos的设计模式</h2><p>PGAS编程模型的一个关键特征是通信和同步的解耦, ATOS以任务并行的方式编程，维护分布式任务队列。GPU worker从队列中获取任务，然后对其进行处理。如果新生成的任务属于本地进程，则将其添加到本地分布式队列中，否则将添加到所有者进程的远程分布式队列中。该程序一直运行，直到满足停止条件或整个分布式队列为空.</p>
<p>开始具体介绍之前先明确一些术语:</p>
<ul>
<li>worker: 作为单个单元一起工作的一个或一组GPU线程(可选择利用共享内存)</li>
<li>task: 在我们的系统中作为单个单元调度的一项或多项工作。任务可以由一个或多个数据元素组成。</li>
<li>应用程序函数f()：处理每个任务的代码。每个应用程序函数都声明其运行所需的Worker大小。</li>
</ul>
<p>三个主要的可配置设计模式:</p>
<ul>
<li>内核实现策略：ATOS可以使用离散内核，也可以使用持久内核。在后一种情况下，只启动一个内核，该内核将一直驻留在GPU上，直到程序结束。这一策略虽然更为复杂，但更适合以内核启动开销为主的应用程序。</li>
<li>队列结构：标准分布式队列与分布式优先级队列。在标准队列中，任务按FIFO顺序处理，而更复杂的优先级队列可以对标记为更高优先级的任务进行优先排序。正如我们稍后将展示的，此功能在异步设置中对于降低投机成本非常重要。</li>
<li>worker size: 提供三个级别的size, thread, warp, CTA</li>
</ul>
]]></content>
      <categories>
        <category>知鱼集</category>
      </categories>
      <tags>
        <tag>conference</tag>
        <tag>SC22</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA技术解读</title>
    <url>//post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB.html</url>
    <content><![CDATA[<h1 id="RDMA技术解读"><a href="#RDMA技术解读" class="headerlink" title="RDMA技术解读"></a>RDMA技术解读</h1><p>本文参考<a href="%5B%E6%8F%AD%E7%A7%98%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84%E2%80%9C%E7%88%B1%E9%A9%AC%E4%BB%95%E2%80%9D%EF%BC%8C12%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82RDMA_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1ZY4y1L7Xq/?spm_id_from=333.337.search-card.all.click&vd_source=aad0e5152e96b4bf095d0017d639153b)">技术蛋老师讲解RDMA的视频</a>, <a href="%5B%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB%EF%BC%9A%E6%B5%85%E8%B0%88RDMA%E6%8A%80%E6%9C%AF_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1QL411G7wo/?spm_id_from=333.337.search-card.all.click&vd_source=aad0e5152e96b4bf095d0017d639153b)">It_server技术分享的视频</a>侵删</p>
<h2 id="传统Socket通信"><a href="#传统Socket通信" class="headerlink" title="传统Socket通信"></a>传统Socket通信</h2><p><img src="/post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118211738044.png" alt="image-20221118211738044"></p>
<p>用户将应用发送出去, 需要先到操作系统内核, 再到网络接口, 然后在接收方收到信息再次经过操作系统内核, 并在用户态分析数据.</p>
<h2 id="RDMA通信模式"><a href="#RDMA通信模式" class="headerlink" title="RDMA通信模式"></a>RDMA通信模式</h2><p><img src="/post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118211907180.png" alt="image-20221118211907180"></p>
<p>绕过内核态, 直接发送数据给硬件. 可以满足高带宽, 低延迟, 低CPU消耗的需求.</p>
<p>RDMA可以释放CPU的负载, 减少数据拷贝, 内存访问, 实现零拷贝和内核旁路.</p>
<ul>
<li>零拷贝:应用程序能够直接执行数据传输, 无需涉及到网络软件栈的情况下, 数据能够被直接发送到缓冲区或者能够直接从缓冲区里被接收</li>
<li>内核旁路: 应用程序可以直接在用户态执行数据传输, 不需要在内核态与用户态之间做上下文切换</li>
</ul>
<h3 id="IB"><a href="#IB" class="headerlink" title="IB"></a>IB</h3><p>RDMA的原生网络协议, 通过专用硬件实现最优的性能, 但是由于专用硬件的原因, InifiniBand要求从L到L4 需要使用自己专用的硬件, 设备成本非常高</p>
<h3 id="RoCE"><a href="#RoCE" class="headerlink" title="RoCE"></a>RoCE</h3><p>RDMA跑在以太网上的一种网络, RoCE v1还没有摆脱Infiniband的束缚, RoCE v2使用UDP+IP, 既可以使用以太网交换机, 可以兼容现有以太网, IP协议使得数据可以被路由.</p>
<p><img src="/post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118212411801.png" alt="image-20221118212411801"></p>
<h3 id="iWARP"><a href="#iWARP" class="headerlink" title="iWARP"></a>iWARP</h3><p>可以更大规模的部署和组网, iWARP是基于TCP的, 传统的iWARP厂商实现时需要兼容的完整的协议栈, 设计和实现成本很高, 不需要交换机支持无损以太网传输, 虽然适用于当前的互联网传输, 但是性能比RoCE要差.</p>
<p><img src="https://img-blog.csdnimg.cn/1b2704ac4511494e8c4c1348d7ad4529.png" alt="img"></p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>为linux设置回收站</title>
    <url>//post/%E4%B8%BAlinux%E8%AE%BE%E7%BD%AE%E5%9B%9E%E6%94%B6%E7%AB%99.html</url>
    <content><![CDATA[<h1 id="为Linux设置回收站"><a href="#为Linux设置回收站" class="headerlink" title="为Linux设置回收站"></a>为Linux设置回收站</h1><p>昨天手快误删了一个很重要的文件夹, 经过一系列的操作最后发现确实是找不回来了, 所以痛定思痛一定要为Linux搭建一个回收站, 参考了网上很多教程, 现在来记录一下搭建过程.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单, 就是自定义一个回收站文件夹, 然后将删除指令自定义成将文件移动到回收站里, 再设置一个定时来定期清空回收站文件夹.</p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="创建回收站文件夹"><a href="#创建回收站文件夹" class="headerlink" title="创建回收站文件夹"></a>创建回收站文件夹</h3><p>我把回收站创建在我的账号的根目录下了, 并且希望平时隐藏, 所以指令如下</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.trash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="回收站相关的命令进行定义"><a href="#回收站相关的命令进行定义" class="headerlink" title="回收站相关的命令进行定义"></a>回收站相关的命令进行定义</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bashrc_trash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建好<code>bashrc_trash</code>文件之后, 在里面添加如下内容</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 为rm重定位为trash的命令, 当执行rm的时候自动执行trash函数</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">rm</span><span class="token operator">=</span>trash
<span class="token comment"># 同上</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">r</span><span class="token operator">=</span>trash
<span class="token comment"># 列出回收站的内容</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">rl</span><span class="token operator">=</span><span class="token string">'ls ~/.trash'</span>
<span class="token comment"># 撤销删除</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">ur</span><span class="token operator">=</span>undelfile

<span class="token comment"># 撤销删除, 就是将回收站中的内容移动回去</span>
<span class="token function-name function">undelfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 <span class="token function">mv</span> <span class="token parameter variable">-i</span> ~/.trash/<span class="token punctuation">\</span><span class="token variable">$@</span> ./
<span class="token punctuation">&#125;</span>

<span class="token comment"># 删除, 就是将当前文件夹移到回收站里, 注意mv指令没有-r参数, 所以使用的时候不用rm -rf, 直接rm -f或者rm就可以</span>
<span class="token function-name function">trash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 <span class="token function">mv</span> <span class="token variable">$@</span> ~/.trash/
<span class="token punctuation">&#125;</span>

<span class="token comment"># 清空回收站, 添加确认操作</span>
<span class="token function-name function">cleartrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 <span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"clear sure?[n]"</span> confirm<span class="token punctuation">;</span>
 <span class="token punctuation">[</span> <span class="token variable">$confirm</span> <span class="token operator">==</span> <span class="token string">'y'</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$confirm</span> <span class="token operator">==</span> <span class="token string">'Y'</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> /bin/rm <span class="token parameter variable">-rf</span> ~/.trash/*
<span class="token punctuation">&#125;</span>

<span class="token comment"># 不需要确认的清空回收站, 用于定时清空, 事实上也可以给cleartrash()配一个参数, 这个以后要是有时间可以再搞一下</span>
<span class="token function-name function">CLEARTRASH</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 /bin/rm <span class="token parameter variable">-rf</span> ~/.trash/*
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="将自定义的指令添加到-bashrc"><a href="#将自定义的指令添加到-bashrc" class="headerlink" title="将自定义的指令添加到.bashrc"></a>将自定义的指令添加到.bashrc</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>打开<code>~/.bashrc</code>之后在其中添加如下指令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># add trash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-f</span> <span class="token string">"~/.bashrc_trash"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">.</span> ~/.bashrc_trash
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样每次启动一个终端就会自动加载我们自定义的指令</p>
<h3 id="定期清空文件夹"><a href="#定期清空文件夹" class="headerlink" title="定期清空文件夹"></a>定期清空文件夹</h3><p>其实到上一步就已经可以使用回收站了, 但是我们希望回收站更完善一点, 能够定时清空回收站, 这样就不用我们手动管理回收站中的内容了, 所以再设置一个定时清空功能. 这个功能要用到<code>crontab </code>指令, Linux <code>crontab</code> 是用来定期执行程序的命令, <code>-e</code>参数可以执行文字编辑器来设定时程表。首先输入如下指令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">crontab</span> <span class="token parameter variable">-e</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 之后会进入到&#x2F;tmp&#x2F;crontab.xFcuCa&#x2F;crontab, 这个如果不指定用户默认是为自己的用户配置的.</p>
<p>之后在里面添加</p>
<pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">0 0 * * 0 CLEARTRASH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这句话的含义是每周日零点清空回收站, 前面的五位数字用来指定时间, 含义如下</p>
<pre class="line-numbers language-none"><code class="language-none">*    *    *    *    *
-    -    -    -    -
|    |    |    |    |
|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)
|    |    |    +---------- 月份 (1 - 12) 
|    |    +--------------- 一个月中的第几天 (1 - 31)
|    +-------------------- 小时 (0 - 23)
+------------------------- 分钟 (0 - 59)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么到此位置我们回收站的配置就完成了, 其实还有更好的方式, 可以让回收站定期清空指定日期以前的数据, 这样安全性会更好一点, 如果以后有时间, 我们就再折腾一下那个方案, 现在的版本也可以实现一个较为安全的<code>rm</code>操作, 妈妈再也不用担心我手快啦!</p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统管理</tag>
      </tags>
  </entry>
</search>
