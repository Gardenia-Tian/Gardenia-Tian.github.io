<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>//post/%E5%90%AF%E7%A8%8B.html</url>
    <content><![CDATA[<h1>年轻人的第一篇博客</h1>
<p>GitHub的博客仓库很早就创立了, 但是拖了很久都没有部署. 总是因为各种原因退缩, 这次终于把界面什么的都配置了一下, 算是勉勉强强能看了, 还有很多功能还没有开发, 这些还需要日后一点一点探索, 不过有了GitHub博客也终于向一名合格的程序员迈进了一步, 希望以后能在这里记录一下自己的学习笔记, 日常心得, 生活碎片, 也希望能给浏览到博客的朋友带来一点点帮助.</p>
<p><img src="/post/1.jpg" alt></p>
]]></content>
      <categories>
        <category>陶然集</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Reproducibility Badges</title>
    <url>//post/Reproducibility-Badges.html</url>
    <content><![CDATA[<h1 id="Reproducibility-Badges"><a href="#Reproducibility-Badges" class="headerlink" title="Reproducibility Badges"></a>Reproducibility Badges</h1><p>最近SC22正在如火如荼地进行, 作为一个科研小白, 我也有简单地远程围观这次会议. 在阅读SC会议的论文的时候, 我们会发现论文上总是有三个圆形的小标志, 所以不禁好奇这个是个什么东西, 经过一番查阅资料这里简单一下这个标志的含义.</p>
<p><img src="/post/Reproducibility-Badges/1.png"></p>
<p>这三个标志是Reproducibility Badges, 也就是再现性徽章. ACM定义了几个再现性徽章，涵盖从轻到强的再现性参与的几个级别，</p>
<h2 id="Artifacts-Evaluated"><a href="#Artifacts-Evaluated" class="headerlink" title="Artifacts Evaluated"></a>Artifacts Evaluated</h2><p>此徽章适用于相关工件已成功完成独立审核的论文。此徽章不需要公开物品。然而，它们确实需要提供给审阅者。区分了两个级别，在任何情况下只能应用其中一个级别.</p>
<h3 id="Artifacts-Evaluated-–-Functional-v1-1"><a href="#Artifacts-Evaluated-–-Functional-v1-1" class="headerlink" title="Artifacts Evaluated – Functional v1.1"></a>Artifacts Evaluated – Functional v1.1</h3><p>与研究相关的人工制品被发现是有记录的、一致的、完整的、可操作的，并且包括适当的验证和确认证据.</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_evaluated_functional_v1_1.png" alt="img"></p>
<h3 id="Artifacts-Evaluated-–-Reusable-v1-1"><a href="#Artifacts-Evaluated-–-Reusable-v1-1" class="headerlink" title="Artifacts Evaluated – Reusable v1.1"></a>Artifacts Evaluated – Reusable v1.1</h3><p>与论文相关的工件的质量大大超过了最小功能。也就是说，它们具有已评估工件的所有质量——功能级别，但除此之外，它们都经过了非常仔细的记录和良好的结构，以便于重用和重新调整用途。特别是，严格遵守研究界对这类文物的规范和标准。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_evaluated_reusable_v1_1.png" alt="img"></p>
<h2 id="Artifacts-Available"><a href="#Artifacts-Available" class="headerlink" title="Artifacts Available"></a>Artifacts Available</h2><p>此徽章适用于相关工件已永久可供检索的论文。</p>
<h3 id="Artifacts-Available-v1-1"><a href="#Artifacts-Available-v1-1" class="headerlink" title="Artifacts Available v1.1"></a>Artifacts Available v1.1</h3><p>作者创建的与本文相关的工件已放置在可公开访问的档案库中。提供了指向该存储库的DOI或链接以及对象的唯一标识符。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/artifacts_available_v1_1.png" alt="img"></p>
<h2 id="Results-Validated"><a href="#Results-Validated" class="headerlink" title="Results Validated"></a>Results Validated</h2><p>此徽章适用于作者以外的个人或团队成功获得论文主要结果的论文。区分两个级别.</p>
<h3 id="Results-Reproduced-v1-1"><a href="#Results-Reproduced-v1-1" class="headerlink" title="Results Reproduced v1.1"></a>Results Reproduced v1.1</h3><p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/results_reproduced_v1_1.png" alt="img"></p>
<p>论文的主要结果是由作者以外的个人或团队进行的后续研究，部分使用作者提供的产品。</p>
<h3 id="Results-Replicated-v1-1"><a href="#Results-Replicated-v1-1" class="headerlink" title="Results Replicated v1.1"></a>Results Replicated v1.1</h3><p>论文的主要结果是由作者以外的个人或团队在后续研究中独立获得的，没有使用作者提供的产品。</p>
<p><img src="https://www.acm.org/binaries/content/gallery/acm/publications/artifact-review-v1_1-badges/results_replicated_v1_1.png" alt="img"></p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>conference</tag>
        <tag>SC</tag>
      </tags>
  </entry>
  <entry>
    <title>RDMA技术解读</title>
    <url>//post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB.html</url>
    <content><![CDATA[<h1 id="RDMA技术解读"><a href="#RDMA技术解读" class="headerlink" title="RDMA技术解读"></a>RDMA技术解读</h1><p>本文参考<a href="%5B%E6%8F%AD%E7%A7%98%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84%E2%80%9C%E7%88%B1%E9%A9%AC%E4%BB%95%E2%80%9D%EF%BC%8C12%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82RDMA_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1ZY4y1L7Xq/?spm_id_from=333.337.search-card.all.click&vd_source=aad0e5152e96b4bf095d0017d639153b)">技术蛋老师讲解RDMA的视频</a>, <a href="%5B%E5%AD%A6%E4%B9%A0%E5%88%86%E4%BA%AB%EF%BC%9A%E6%B5%85%E8%B0%88RDMA%E6%8A%80%E6%9C%AF_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1QL411G7wo/?spm_id_from=333.337.search-card.all.click&vd_source=aad0e5152e96b4bf095d0017d639153b)">It_server技术分享的视频</a>侵删</p>
<h2 id="传统Socket通信"><a href="#传统Socket通信" class="headerlink" title="传统Socket通信"></a>传统Socket通信</h2><p><img src="/post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118211738044.png" alt="image-20221118211738044"></p>
<p>用户将应用发送出去, 需要先到操作系统内核, 再到网络接口, 然后在接收方收到信息再次经过操作系统内核, 并在用户态分析数据.</p>
<h2 id="RDMA通信模式"><a href="#RDMA通信模式" class="headerlink" title="RDMA通信模式"></a>RDMA通信模式</h2><p><img src="/post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118211907180.png" alt="image-20221118211907180"></p>
<p>绕过内核态, 直接发送数据给硬件. 可以满足高带宽, 低延迟, 低CPU消耗的需求.</p>
<p>RDMA可以释放CPU的负载, 减少数据拷贝, 内存访问, 实现零拷贝和内核旁路.</p>
<ul>
<li>零拷贝:应用程序能够直接执行数据传输, 无需涉及到网络软件栈的情况下, 数据能够被直接发送到缓冲区或者能够直接从缓冲区里被接收</li>
<li>内核旁路: 应用程序可以直接在用户态执行数据传输, 不需要在内核态与用户态之间做上下文切换</li>
</ul>
<h3 id="IB"><a href="#IB" class="headerlink" title="IB"></a>IB</h3><p>RDMA的原生网络协议, 通过专用硬件实现最优的性能, 但是由于专用硬件的原因, InifiniBand要求从L到L4 需要使用自己专用的硬件, 设备成本非常高</p>
<h3 id="RoCE"><a href="#RoCE" class="headerlink" title="RoCE"></a>RoCE</h3><p>RDMA跑在以太网上的一种网络, RoCE v1还没有摆脱Infiniband的束缚, RoCE v2使用UDP+IP, 既可以使用以太网交换机, 可以兼容现有以太网, IP协议使得数据可以被路由.</p>
<p><img src="/post/RDMA%E6%8A%80%E6%9C%AF%E8%A7%A3%E8%AF%BB/image-20221118212411801.png" alt="image-20221118212411801"></p>
<h3 id="iWARP"><a href="#iWARP" class="headerlink" title="iWARP"></a>iWARP</h3><p>可以更大规模的部署和组网, iWARP是基于TCP的, 传统的iWARP厂商实现时需要兼容的完整的协议栈, 设计和实现成本很高, 不需要交换机支持无损以太网传输, 虽然适用于当前的互联网传输, 但是性能比RoCE要差.</p>
<p><img src="https://img-blog.csdnimg.cn/1b2704ac4511494e8c4c1348d7ad4529.png" alt="img"></p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>为linux设置回收站</title>
    <url>//post/%E4%B8%BAlinux%E8%AE%BE%E7%BD%AE%E5%9B%9E%E6%94%B6%E7%AB%99.html</url>
    <content><![CDATA[<h1 id="为Linux设置回收站"><a href="#为Linux设置回收站" class="headerlink" title="为Linux设置回收站"></a>为Linux设置回收站</h1><p>昨天手快误删了一个很重要的文件夹, 经过一系列的操作最后发现确实是找不回来了, 所以痛定思痛一定要为Linux搭建一个回收站, 参考了网上很多教程, 现在来记录一下搭建过程.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理其实很简单, 就是自定义一个回收站文件夹, 然后将删除指令自定义成将文件移动到回收站里, 再设置一个定时来定期清空回收站文件夹.</p>
<h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="创建回收站文件夹"><a href="#创建回收站文件夹" class="headerlink" title="创建回收站文件夹"></a>创建回收站文件夹</h3><p>我把回收站创建在我的账号的根目录下了, 并且希望平时隐藏, 所以指令如下</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> ~/.trash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="回收站相关的命令进行定义"><a href="#回收站相关的命令进行定义" class="headerlink" title="回收站相关的命令进行定义"></a>回收站相关的命令进行定义</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bashrc_trash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建好<code>bashrc_trash</code>文件之后, 在里面添加如下内容</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 为rm重定位为trash的命令, 当执行rm的时候自动执行trash函数</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">rm</span><span class="token operator">=</span>trash
<span class="token comment"># 同上</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">r</span><span class="token operator">=</span>trash
<span class="token comment"># 列出回收站的内容</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">rl</span><span class="token operator">=</span><span class="token string">'ls ~/.trash'</span>
<span class="token comment"># 撤销删除</span>
<span class="token builtin class-name">alias</span> <span class="token assign-left variable">ur</span><span class="token operator">=</span>undelfile

<span class="token comment"># 撤销删除, 就是将回收站中的内容移动回去</span>
<span class="token function-name function">undelfile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 <span class="token function">mv</span> <span class="token parameter variable">-i</span> ~/.trash/<span class="token punctuation">\</span><span class="token variable">$@</span> ./
<span class="token punctuation">&#125;</span>

<span class="token comment"># 删除, 就是将当前文件夹移到回收站里, 注意mv指令没有-r参数, 所以使用的时候不用rm -rf, 直接rm -f或者rm就可以</span>
<span class="token function-name function">trash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 <span class="token function">mv</span> <span class="token variable">$@</span> ~/.trash/
<span class="token punctuation">&#125;</span>

<span class="token comment"># 清空回收站, 添加确认操作</span>
<span class="token function-name function">cleartrash</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 <span class="token builtin class-name">read</span> <span class="token parameter variable">-p</span> <span class="token string">"clear sure?[n]"</span> confirm<span class="token punctuation">;</span>
 <span class="token punctuation">[</span> <span class="token variable">$confirm</span> <span class="token operator">==</span> <span class="token string">'y'</span> <span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">[</span> <span class="token variable">$confirm</span> <span class="token operator">==</span> <span class="token string">'Y'</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> /bin/rm <span class="token parameter variable">-rf</span> ~/.trash/*
<span class="token punctuation">&#125;</span>

<span class="token comment"># 不需要确认的清空回收站, 用于定时清空, 事实上也可以给cleartrash()配一个参数, 这个以后要是有时间可以再搞一下</span>
<span class="token function-name function">CLEARTRASH</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
 /bin/rm <span class="token parameter variable">-rf</span> ~/.trash/*
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="将自定义的指令添加到-bashrc"><a href="#将自定义的指令添加到-bashrc" class="headerlink" title="将自定义的指令添加到.bashrc"></a>将自定义的指令添加到.bashrc</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> ~/.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>打开<code>~/.bashrc</code>之后在其中添加如下指令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># add trash</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-f</span> <span class="token string">"~/.bashrc_trash"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token builtin class-name">.</span> ~/.bashrc_trash
<span class="token keyword">fi</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样每次启动一个终端就会自动加载我们自定义的指令</p>
<h3 id="定期清空文件夹"><a href="#定期清空文件夹" class="headerlink" title="定期清空文件夹"></a>定期清空文件夹</h3><p>其实到上一步就已经可以使用回收站了, 但是我们希望回收站更完善一点, 能够定时清空回收站, 这样就不用我们手动管理回收站中的内容了, 所以再设置一个定时清空功能. 这个功能要用到<code>crontab </code>指令, Linux <code>crontab</code> 是用来定期执行程序的命令, <code>-e</code>参数可以执行文字编辑器来设定时程表。首先输入如下指令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">crontab</span> <span class="token parameter variable">-e</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p> 之后会进入到&#x2F;tmp&#x2F;crontab.xFcuCa&#x2F;crontab, 这个如果不指定用户默认是为自己的用户配置的.</p>
<p>之后在里面添加</p>
<pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">0 0 * * 0 CLEARTRASH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这句话的含义是每周日零点清空回收站, 前面的五位数字用来指定时间, 含义如下</p>
<pre class="line-numbers language-none"><code class="language-none">*    *    *    *    *
-    -    -    -    -
|    |    |    |    |
|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)
|    |    |    +---------- 月份 (1 - 12) 
|    |    +--------------- 一个月中的第几天 (1 - 31)
|    +-------------------- 小时 (0 - 23)
+------------------------- 分钟 (0 - 59)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>那么到此位置我们回收站的配置就完成了, 其实还有更好的方式, 可以让回收站定期清空指定日期以前的数据, 这样安全性会更好一点, 如果以后有时间, 我们就再折腾一下那个方案, 现在的版本也可以实现一个较为安全的<code>rm</code>操作, 妈妈再也不用担心我手快啦!</p>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-11-22随笔</title>
    <url>//post/2022-11-22%E9%9A%8F%E7%AC%94.html</url>
    <content><![CDATA[<h1 id="22-11-22随笔"><a href="#22-11-22随笔" class="headerlink" title="22-11-22随笔"></a>22-11-22随笔</h1><p>最近有一点点不开心, 觉得自己的状态特别拧巴. 课题被同学批评，说问题没有想清楚，怎么做，做什么都没有搞清楚就贸然上手了。说自己搞这个很难出成果，而且基本做不下去，总之就是各种被批评。更难受的是我不知道怎么反驳他们，我很想为自己的课题争取，为他辩解，但是我什么也说不出来，我只觉得他们说的对。我想我应该把不懂的地方问出来，可是又不好意思又不敢。我应该静下心来好好想想同学们的意见，可是心里满满的都是大家的批评，又不能好好去思考究竟是哪里的问题。</p>
<p>所以就陷入了这样非常拧巴的状态：<font style="background-color:#8bc34a">觉得应该动手去改但是又不真正的去行动；只能坐在这里焦虑不断内耗。</font></p>
<p>昨天和同学们聊了一下现在这种状态，大家也是各种安慰，告诉我明天会好的，但是自己觉得心里一直都没有想清楚，我找不到问题的根源，我没办法解决这种心态。仔细想想自己这样的状态应该是因为：</p>
<ol>
<li>被批评了，心里不开心</li>
<li>想得太多而做的太少，导致想反驳但是肚子里没有墨水，反驳不出来</li>
<li>觉得大家说的很对，这个课题做不下去，但是也没有新课题可以做，时间又很紧张了，担心自己毕不了业</li>
<li>觉得自己不是科研这块料，觉得身边的人都太强了，我不配待在这，我插不上他们的话，他们说的我都不懂，我什么也不会</li>
<li>明明什么都不会，还装出一副什么都会的样子，想问又不问，故作一副大佬的样子，其实外强中干</li>
</ol>
<p>那现在就来分析一下每一点，争取解决问题，从最好分析的开始：</p>
<ul>
<li><p>第二点：其实解决方案已经列出来了，想的太多而做的太少。想的多了，问题就多了；做的多了，答案就多了。既然觉得可做，既然觉得有办法，那就去做，去动手，去实践，既然觉得他们不对，那就努力去辩驳，去为自己发声！</p>
</li>
<li><p>第四点：还是自己内心戏太足了，只是被批评了一下，有什么就不是这块料的地方呢，以后路还长着呢，怎么能因为一点小挫折就放弃呢。而且大部分人还没有努力到要拼天赋的地步，等你足够努力然后发现自己还是不够敏锐再来评价自己是不是科研这块料，如果你不够努力，你会发现自己不是任何一块料。</p>
</li>
<li><p>第三点：和第二点同解。但是这一点还多了一种心理的因素。但是永远要牢记，学习是为了快乐。<code>学习本身就是足够幸福的过程，享受知识的同时，不要畏惧挑战。</code>各种毕业的评价标准，本质是由整个社会制定的残酷淘汰标准，它可以要求很多人，但如果你不在意，那它也没那么重要。<code>与探索未知的美妙相比，世界上大部分噩运，都不再重要。</code>所以，不管这条路走不走得通，能不能可行，其实也没有那么重要，你做出了重要的探索，这一路上的风景，你都没有错过。</p>
</li>
<li><p>第一点：哪有不被批评的呢。要不是他们，你也不会这样审视自己，也不会更加坚定自己的想法，也不会更加明确问题的方向，要是没有批评，你现在还在浑浑噩噩无所事事呢，多亏了他们，才没让你偏航太远。</p>
</li>
<li><p>第五点：这一点的答案是和同学的聊天中找到的。我现在还是一个二十多岁的年轻人，是一个刚上研一的学生，以前没有科研经历，没有竞赛经历，没读过什么论文，没什么实习经验，什么都不会，实在太正常了。究竟是什么让我觉得自己很厉害呢？究竟是什么让我觉得自己高人一等呢？不能放低自己的姿态，永远以一副高高在上的状态，那就只能永远什么也学不到。放低自己的姿态，允许自己犯错，因为自己本身就不是什么很厉害的人，但这不丢人，因为自己扎实地走在成为很厉害的人的路上。二十多岁什么都不会，总好过三十多岁什么都不会。</p>
<p>这就好像达克尔效应描述的一样：越是无知的人就越自信。当一个人知识越来越多，自信心会下降，但是突破临界点以后，自信心会回升，但之后不论怎么回升，都不如一开始一无所知时那么自信。即越是知识丰富的人越能意识到自己的不足，也越能发现、承认与学习别人的优点。</p>
</li>
</ul>
<p><img src="/post/2022-11-22%E9%9A%8F%E7%AC%94/22-11-22%E9%9A%8F%E7%AC%94.jpg" alt="22-11-22随笔"></p>
<p>或许现在就是自己走向<em>绝望之谷</em>的过程，也可能是在走向<em>愚昧之巅</em>的过程，但是无论如何，要知道自己的能力是在提升的。我更希望现在的状态是走向<em>绝望之谷</em>的过程，因此，勇于接受自己的无知，勇于向他人学习，才是你应该做的，这个过程，就是成长的过程啊。</p>
<p>所以，加油呀，就像博客的简介那样，是La La Land里的一句台词</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>People love what other people are passionate about.                   ——《La La Land》</p></blockquote>
]]></content>
      <categories>
        <category>陶然集</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>rCUDA学习笔记</title>
    <url>//post/rCUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="rCUDA学习笔记"><a href="#rCUDA学习笔记" class="headerlink" title="rCUDA学习笔记"></a>rCUDA学习笔记</h1><h2 id="工作背景"><a href="#工作背景" class="headerlink" title="工作背景"></a>工作背景</h2><p>人CUDA是巴仑西亚理工大学和西班牙海梅一世大学开发的一个工作, 到现在已经有十余年的历史, 并且目前仍在维护. 欧洲的很多工作都是这样子默默无闻, 但是能坚持开发很久的工作, 并且在很久以后突然产生它的用途被大家所瞩目, 这一点真的很值得敬佩. 感觉这样的精神就是我所理解的学者精神.</p>
<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>核心思想是类似远程过程调用, 将使用GPU的核函数发送到远程的GPU端供GPU使用, 这样做主要的开销在数据传输的通信上, 作者在文中对数据传输部分做了很大的优化. 但最终的运行效果差强人意, 相对于本地未初始化的节点表现得还挺好的, 但是如果本地已经初始化, 远程还是比不过本地的, </p>
<p><img src="/post/rCUDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221210105200418.png" alt="image-20221210105200418"></p>
<p>不过思想还是可以借鉴, 将GPU任务发送给目标进程执行, 减少显存的占用同时实现隔离, 但是这样扩展性仍然受限, 有多少个GPU就有多少个进程, 这些进程之间并行执行, 但是进程内部是串行的.</p>
]]></content>
      <categories>
        <category>索道集</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>GPU</tag>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>世界没有变糟糕, 只不过是我长大了</title>
    <url>//post/%E4%B8%96%E7%95%8C%E6%B2%A1%E6%9C%89%E5%8F%98%E7%B3%9F%E7%B3%95-%E5%8F%AA%E4%B8%8D%E8%BF%87%E6%98%AF%E6%88%91%E9%95%BF%E5%A4%A7%E4%BA%86.html</url>
    <content><![CDATA[<h1 id="世界没有变糟糕-只不过是我长大了"><a href="#世界没有变糟糕-只不过是我长大了" class="headerlink" title="世界没有变糟糕, 只不过是我长大了"></a>世界没有变糟糕, 只不过是我长大了</h1><p>国内疫情全面放开了, 身边的人一个接一个变成阳性, 父母也不能幸免, 所幸症状不是十分严重, 母亲已经没什么严重的症状了, 父亲现在虽然退烧但是浑身疼, 胸胁胀痛, 头痛这些症状都还没有缓解, 哥哥今天也嗓子疼了, 甚至生不出任何一丝侥幸心理, 我们心里都清楚, 跑不掉的, 基本就是阳了. </p>
<p> 我远在学校回不去家里, 看着他们一个个变阳除了跟着着急什么也做不了, 只能再加紧保护好自己. 学校里也出现了很多阳性, 但是学校彻底放开, 根本管不住这些. 每天看着新闻上的报道完全不知道什么该信什么不该信, 不知道这样的情况什么时候会缓解, 什么时候能变好. 人类会不会永远和新冠共存, 新冠还会不会产生更加难缠的变异, 究竟有没有后遗症, 会不会未来几十年的人类都是病怏怏的. 为什么我的青春岁月里会经历这样的事情, 为什么世界会变成这样……</p>
]]></content>
      <categories>
        <category>陶然集</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>弱小和无知不是生存的障碍，傲慢才是</title>
    <url>//post/%E5%BC%B1%E5%B0%8F%E5%92%8C%E6%97%A0%E7%9F%A5%E4%B8%8D%E6%98%AF%E7%94%9F%E5%AD%98%E7%9A%84%E9%9A%9C%E7%A2%8D%EF%BC%8C%E5%82%B2%E6%85%A2%E6%89%8D%E6%98%AF.html</url>
    <content><![CDATA[<h1 id="弱小和无知不是生存的障碍，傲慢才是"><a href="#弱小和无知不是生存的障碍，傲慢才是" class="headerlink" title="弱小和无知不是生存的障碍，傲慢才是"></a>弱小和无知不是生存的障碍，傲慢才是</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在科研的道路上总是有各种各样的心态起伏, 也遇到各种各样的困难, 我希望能够在这里记录下自己一路上的心路历程, 让自己回望来路的时候, 能看到来时的方向.</p>
<h2 id="2022-12-15"><a href="#2022-12-15" class="headerlink" title="2022-12-15"></a>2022-12-15</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>弱小和无知不是生存的障碍，傲慢才是。       ——刘慈欣</p></blockquote>
<p>刚开始接触科研的时候每天都很焦虑的找课题, 但是一直都没有什么收获, 后来老师给了一个方向, 就在这个方向上摸索, 简单做了几个小实验, 觉得这个方向上可做的事情很多, 明明没读过什么文献, 却冒出了一大堆的想法, 觉得这个也可以, 那个也可以. 现在想想这些想法真的很幼稚. 因为有了课题, 就觉得自己有了方向, 每天也不认真搞科研, 觉得已经有想法的, 随便弄弄就可以发论文, 不着急不着急, 甚至觉得这些东西做出来了就可以发顶会, 所以开始快乐摆烂. 直到后来上手做了几个小实验, 发现这些个想法根本就站不住脚, 而且很多想过的东西其实都已经被实现了. 然后突然觉得, 自己前段时间都是在干什么, 明明没有真正深入的了解过一个领域, 却好高骛远的觉得自己什么都会了. 明明看到多少师兄反复改稿改了几年都没能被顶会接收, 却傲慢的觉得自己一投就中。然后就不可避免的想到大刘的话，“弱小和无知不是生存的障碍，傲慢才是”。</p>
<p>决定纠正自己着急的心态，不要好高骛远，不要眼高手低，真正多读一些论文，多做一些实验，夯实自己的基础，让学习变得水到渠成。还有要记得自己的初心，读研是为了快乐，是为了探索人类知识的边界，不是为了发论文，永远不要将学习变成一件很功利的事情，因为知识远比那些物质要高贵。</p>
<p>要记住，一个优秀的成果背后的努力不是简简单单的，需要的汗水，思考，努力，远比你能想象到的要多得多。但也不要害怕，只要在这个过程中，倾注了热情与心血，如论结果如何，都很值得。</p>
]]></content>
      <categories>
        <category>陶然集</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Ray学习笔记</title>
    <url>//post/Ray%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<h1 id="Ray学习笔记"><a href="#Ray学习笔记" class="headerlink" title="Ray学习笔记"></a>Ray学习笔记</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>tasks</td>
<td>在Ray中, 任务是很轻量级的, 一个task指的实际上是一个remote函数</td>
</tr>
<tr>
<td>worker</td>
<td>可以理解成一个python进程</td>
</tr>
<tr>
<td>actors</td>
<td>将task从函数扩展到了类, 当创建一个actor的时候, 同时还会创建一个新的worker, 类的方法被绑定在这个特定的worker上, worker可以访问和修改类的状态</td>
</tr>
<tr>
<td>objects</td>
<td>一个worker或者一个actor实例被创建出来之后就变成了object, 这些object可以存在在集群中的任何位置, 可以通过ref来访问</td>
</tr>
<tr>
<td>placement groups</td>
<td>允许用户跨多个节点自动保留资源, 往往用于两种情况:<br>(1)组调度, 我们需要一组任务同时开始; (2)最大化数据局部性, 减少数据移动的开销</td>
</tr>
<tr>
<td>environment dependencies</td>
<td>因为tasks或者actors可能在环境中的任何一个节点执行, 所以需要解决不同节点之间的环境依赖问题, 这个问题要么要用户提前在节点上都准备好需要的环境, 或者使用Ray的<a href="https://docs.ray.io/en/latest/ray-core/handling-dependencies.html#runtime-environments">runtime environments</a>动态安装这些环境.</td>
</tr>
</tbody></table>
<h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><p>Ray允许用户指定资源, </p>
<p><img src="/Ray%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221221174102006.png" alt="image-20221221174102006"></p>
]]></content>
      <categories>
        <category>索道集</category>
      </categories>
      <tags>
        <tag>体系结构</tag>
        <tag>系统管理</tag>
        <tag>计算框架</tag>
      </tags>
  </entry>
  <entry>
    <title>CTR prediction</title>
    <url>//post/CTR-prediction.html</url>
    <content><![CDATA[<h1 id="CTR-Prediction"><a href="#CTR-Prediction" class="headerlink" title="CTR Prediction"></a>CTR Prediction</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>本文参考:</p>
<p>[BarsCTR:]: <a href="https://arxiv.org/abs/2009.05794">https://arxiv.org/abs/2009.05794</a>	“《BarsCTR: Open Benchmarking for Click-Through Rate Prediction》”</p></blockquote>
<p>Click-through rate (CTR) prediction点击率预测的目标是预测用户点击给定商品的概率。如何提高CTR预测的准确性仍然是一个具有挑战性的研究问题。与其他数据类型(如图像和文本)相比，CTR预测问题中的数据通常采用表格格式，由多个不同字段的数值、类别或多值(或序列)特征组成。<strong>样本量通常很大，但特征空间高度稀疏。</strong>例如，Google Play中的应用推荐涉及数十亿个样本和数百万个特征。</p>
<h3 id="CTR预测模型的组成"><a href="#CTR预测模型的组成" class="headerlink" title="CTR预测模型的组成"></a>CTR预测模型的组成</h3><p>一般来说，CTR预测模型由以下几个关键部分组成:</p>
<ol>
<li><p>Feature Embedding: CTR预测的输入实例通常包含三组特征，即，用户简介，项目简介，以及上下文信息. 每组特征都有一些字段，如下所示:</p>
<ul>
<li>用户简介:年龄、性别、城市、职业、兴趣等</li>
<li>商品简介:商品ID、类别、标签、品牌、卖家、价格等。</li>
<li>上下文:工作日、时间、位置、槽位号等。</li>
</ul>
<p>每个字段中的特征可以是类别、数值或多值的(例如，单个项目的多个标记)。由于大多数特征非常稀疏，经过one-hot或multi-hot编码后形成高维特征空间，通常采用特征嵌入将这些特征映射到低维密集向量中。下面我们总结了类别，数值，多值这三种特征的嵌入过程。</p>
<ul>
<li>类别：对于类别<code>i</code>,给定one-hot特征向量$x_i$, 嵌入矩阵$V_i \in R^{d\times n}$, <code>d</code>是嵌入维度, <code>n</code>是字母表个数(类别个数). 嵌入后的向量是<code>d * 1</code>的. </li>
<li>数值: 对于数值特征<code>j</code>, 我们有多种嵌入方式:<ul>
<li>通过手动设计(例如，将13 ~ 19岁的年龄分组为青少年)或通过在数字特征上训练决策树(例如，GBDT)，然后将它们以类别特征的方式嵌入;</li>
<li>给定一个规范化的标量值$x_j$, $e_j &#x3D; v_j x_j, \quad v_j \in R^d$是所有特征<code>j</code>共享的嵌入向量; </li>
<li>除了将每个值存储到一个类别中或为每个数值字段分配一个向量, 还可以利用<code>AutoDis</code>, 一种数值特征嵌入方法，利用元嵌入矩阵对数值特征进行动态类别化和嵌入计算。</li>
</ul>
</li>
<li>多值: 对于多值特征<code>h</code>, 每个特征都可以表示为一个序列. $e_h &#x3D; V_h[x_{h_1},x_{h_2},x_{h_3},…,x_{h_k}] \in R^{d \times k}$, 其中$x_{h_k}$是一个one-hot向量, <code>k</code>表示序列的最大长度, 嵌入结果$e_h$可以被进一步嵌入为一个<code>d</code>维向量(均值池化&#x2F;求和池化). 进一步的潜在改进是应用序列模型，如DIN中的目标注意力和DIEN中的GRU，来聚合多值行为序列特征。</li>
</ul>
</li>
<li><p>Feature Interaction: 在特征嵌入后，可以直接应用任何分类模型进行CTR预测。然而，对于CTR预测任务，特征之间的相互作用(又称特征连接, feature conjunctions)是提高分类性能的核心。在因子分解机(factorization machines, FM)中指明，内积为捕获成对特征相互作用的简单而有效的方法。自从FM的成功以来，大量的研究都致力于以不同的方式捕捉特征之间的相互作用。自从FM的成功以来，大量的研究都致力于以不同的方式捕捉特征之间的相互作用。此外，目前大多数工作研究一种将显式和隐式特征交互与普通全连接网络(即mlp)结合起来的方法。</p>
</li>
<li><p>Loss Function: 二元交叉熵损失在CTR预测任务中被广泛应用，其定义如下;<br>$$<br>L &#x3D; -\frac{1}{N}\Sigma_D (y\ log\hat y + (1-y)log(1-\hat y))<br>$$<br>其中<code>D</code>是有<code>N</code>个样本的数据集, <code>y</code>和$\hat y$分别表示真实的和估计的点击概率, $\hat y &#x3D; \sigma (\phi (x)),\quad \phi(x)$代表模型函数, CTR预测建模的核心在于如何构建模型$\phi(x)$, 并通过训练数据学习模型参数.</p>
</li>
</ol>
<h3 id="经典模型"><a href="#经典模型" class="headerlink" title="经典模型"></a>经典模型</h3><p>本节详见参考论文</p>
<ol>
<li>Shallow Models: 工业CTR预测任务通常具有大规模的数据。因此，浅层模型因其简单高效而得到了广泛的应用。即使在今天，LR[40]和FM[39]仍然是工业中部署的两个强大的基线模型。(e.g. LR, FM, FFM, HOFM, FwFM, LorentzFM)</li>
<li>Deep Models: 目前，深度神经网络在CTR预测方面得到了广泛的研究和应用。与浅模型相比，深度模型在利用非线性激活函数捕捉复杂的高阶特征交互方面更强大，通常会产生更好的性能。然而，在实际应用中，效率已成为深度模型规模化的主要瓶颈。(e.g. DNN, CCPM, Wide&amp;Deep, IPNN, DeepCross, NFM, AFM, DeepFM, DCN, xDeepFM, HFM+, FGCNN, AutoInt+, FiGNN, ONN, FiBiNET, AFN+, InterHAt)</li>
</ol>
]]></content>
      <categories>
        <category>索道集</category>
      </categories>
      <tags>
        <tag>推荐系统</tag>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>Nsight Compute使用不完全记录</title>
    <url>//post/Nsight-Compute%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%AE%8C%E5%85%A8%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1 id="Nsight-Compute使用不完全记录"><a href="#Nsight-Compute使用不完全记录" class="headerlink" title="Nsight Compute使用不完全记录"></a>Nsight Compute使用不完全记录</h1><p>Nsight System是Nvidai推出的一款性能分析工具,  对于高性能计算工作者来说是一个分析利器. 但是网上并没有找到非常清晰的使用指南, 官方文档虽然书写的很清晰, 但是内容过于繁杂, 所以这里记录一下自己的使用经历, 方便自己以后的使用的同时, 希望能给其他朋友做一个参考.</p>
]]></content>
      <categories>
        <category>清浅集</category>
      </categories>
      <tags>
        <tag>GPU</tag>
        <tag>性能测试</tag>
        <tag>profile</tag>
        <tag>roofline</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的STL容器</title>
    <url>//post/C-%E7%9A%84STL%E5%AE%B9%E5%99%A8.html</url>
    <content><![CDATA[<h1>C++的STL容器</h1>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>本文参考自《C语言中文网》中的<a href="http://c.biancheng.net/stl/">STL</a>部分，侵删。</p></blockquote>
<p>C++的标准模板库(STL)的容器主要可以分为序列式容器, 关联式容器, 无序关联式容器.</p>
<ol>
<li>
<p>序列式容器:  包括 array、vector、deque、list 和 forward_list 容器。</p>
<p>所谓STL序列式容器，其共同的特点是不会对存储的元素进行排序，元素排列的顺序取决于存储它们的顺序。</p>
</li>
<li>
<p>关联式容器: 包括map, multimap, set以及multiset这四种容器. 和序列式容器不同的是, 关联式容器在存储容器时, 还会为每个元素配备一个间, 整体以键值对的方式存储在容器中. 相比于前者, 关联式容器可以通过键值直接找到对应的元素, 而无需遍历整个容器. 另外, 关联式容器在存储元素, 默认会根据各元素键值的大小做升序排序.</p>
</li>
<li>
<p>无序关联式容器: 包括unordered_map, unordered_multimap, unordered_set, unordered_multiset. 又称哈希容器. 和关联式容器一样, 此类容器存储的也是键值对元素, 关联式容器默认情况下会对存储的元素做升序排序, 而无序关联式容器不会. 和其他类容器相比, 无序关联容器擅长通过指定键查找对应的值, 而遍历容器中存储元素的效率不如关联式容器.</p>
</li>
<li>
<p>容器适配器: 包括 stack、queue、priority_queue. 容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。</p>
</li>
</ol>
<h2 id="序列式容器">序列式容器</h2>
<p>由于本文主要是自用, 因此在成员函数部分仅记录了一些自己不熟悉的函数, 如果需要更多的讲解, 可以详见<a href="http://c.biancheng.net/stl/">C语言中文网</a></p>
<h3 id="stl-array">STL array</h3>
<p>array 容器是 C++ 11 标准中新增的序列容器，简单地理解，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数。在使用上，它比普通数组更安全，且效率并没有因此变差。和其它容器不同，<code>array 容器的大小是固定的，无法动态的扩展或收缩</code>，这也就意味着，在使用该容器的过程无法借由增加或移除元素而改变其大小，<code>它只允许访问或者替换存储的元素</code>。</p>
<p>array 容器以类模板的形式定义在 <array> 头文件，并位于命名空间 std 中,  array 容器有多种初始化方式，如下代码展示了如何创建具有 10 个 double 类型元素的 array 容器, <code>array 容器不会做默认初始化操作</code>。</array></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 使用这种方式创建的容器中，各个元素的值是不确定的
std::array&lt;double, 10&gt; values;
&#x2F;&#x2F; 使用该语句，容器中所有的元素都会被初始化为 0.0。
std::array&lt;double, 10&gt; values &#123;&#125;;
&#x2F;&#x2F; 只初始化了前 4 个元素，剩余的元素都会被初始化为 0.0
std::array&lt;double, 10&gt; values &#123;0.5,1.0,1.5,,2.0&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>array的操作:</p>
<table>
<thead>
<tr>
<th><strong>成员函数</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>front()</td>
<td>返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。</td>
</tr>
<tr>
<td>back()</td>
<td>返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。</td>
</tr>
<tr>
<td>data()</td>
<td>返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。</td>
</tr>
<tr>
<td>fill(val)</td>
<td>将 val 这个值赋值给容器中的每个元素。</td>
</tr>
<tr>
<td>array1.swap(array2)</td>
<td>交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。</td>
</tr>
</tbody>
</table>
<p>另外，在 &lt;array&gt; 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
&#x2F;&#x2F;需要引入 array 头文件
#include &lt;array&gt;
using namespace std;
int main()
&#123;
    std::array&lt;int, 4&gt; values&#123;&#125;;
    &#x2F;&#x2F;初始化 values 容器为 &#123;0,1,2,3&#125;
    for (int i &#x3D; 0; i &lt; values.size(); i++) &#123;
        values.at(i) &#x3D; i;
    &#125;
    &#x2F;&#x2F;使用 get() 重载函数输出指定位置元素
    cout &lt;&lt; get&lt;3&gt;(values) &lt;&lt; endl;
    &#x2F;&#x2F;如果容器不为空，则输出容器中所有的元素
    if (!values.empty()) &#123;
        for (auto val &#x3D; values.begin(); val &lt; values.end(); val++) &#123;
            cout &lt;&lt; *val &lt;&lt; &quot; &quot;;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>array通过<code>容器名[]</code>的方式直接访问和使用容器中的元素, 但使用这样方式，由于没有做任何边界检查，所以即便使用越界的索引值去访问或存储元素，也不会被检测到。为了能够有效地避免越界访问的情况，可以使用 array 容器提供的 at() 成员函数, 当传给 at() 的索引是一个越界值时，程序会抛出 std::out_of_range 异常。</p>
<h3 id="stl-vector">STL vector</h3>
<p>array 实现的是静态数组（容量固定的数组），而 vector 实现的是一个动态数组，即可以进行元素的插入和删除. vector 常被称为向量容器，因为该容器擅长在尾部插入或删除元素，在常量时间内就可以完成，时间复杂度为<code>O(1)</code>；而对于在容器头部或者中部插入或删除元素，则花费时间要长一些（移动元素需要耗费时间），时间复杂度为线性阶<code>O(n)</code>。</p>
<p>vector的操作:</p>
<table>
<thead>
<tr>
<th>函数成员</th>
<th>函数功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_size()</td>
<td>返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。</td>
</tr>
<tr>
<td>resize()</td>
<td>改变实际元素的个数。</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回当前容量。</td>
</tr>
<tr>
<td>reserve()</td>
<td>增加容器的容量。</td>
</tr>
<tr>
<td>shrink _to_fit()</td>
<td>将内存减少到等于当前元素实际所使用的大小。</td>
</tr>
<tr>
<td>assign()</td>
<td>用新元素替换原有内容。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器的所有元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在指定的位置直接生成一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在序列尾部生成一个元素。</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;int&gt; demo&#123;1,2&#125;;
   &#x2F;&#x2F;第一种格式用法
   demo.insert(demo.begin() + 1, 3);&#x2F;&#x2F;&#123;1,3,2&#125;
   &#x2F;&#x2F;第二种格式用法
   demo.insert(demo.end(), 2, 5);&#x2F;&#x2F;&#123;1,3,2,5,5&#125;
   &#x2F;&#x2F;第三种格式用法
   std::array&lt;int,3&gt;test&#123; 7,8,9 &#125;;
   demo.insert(demo.end(), test.begin(), test.end());&#x2F;&#x2F;&#123;1,3,2,5,5,7,8,9&#125;
   &#x2F;&#x2F;第四种格式用法
   demo.insert(demo.end(), &#123; 10,11 &#125;);&#x2F;&#x2F;&#123;1,3,2,5,5,7,8,9,10,11&#125;
&#x2F;&#x2F;emplace() 每次只能插入一个 int 类型元素, emplace效率高于insert
   demo1.emplace(demo1.begin(), 3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="stl-deque">STL deque</h3>
<p>deque 是 double-ended queue 的缩写，又称双端队列容器。和 vector 不同的是，deque 还擅长在序列头部添加或删除元素，所耗费的时间复杂度也为常数阶<code>O(1)</code>. 并且更重要的一点是，<code>deque 容器中存储元素并不能保证所有元素都存储到连续的内存空间中。当需要向序列两端频繁的添加或删除元素时，应首选 deque 容器。</code></p>
<p>成员函数内容和Vector基本一致.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;初始化一个空deque容量
deque&lt;int&gt;d;
&#x2F;&#x2F;向d容器中的尾部依次添加 1，2,3
d.push_back(1); &#x2F;&#x2F;&#123;1&#125;
d.push_back(2); &#x2F;&#x2F;&#123;1,2&#125;
d.push_back(3); &#x2F;&#x2F;&#123;1,2,3&#125;
&#x2F;&#x2F;向d容器的头部添加 0 
d.push_front(0); &#x2F;&#x2F;&#123;0,1,2,3&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和 array、vector 容器一样，可以采用普通数组访问存储元素的方式，访问 deque 容器中的元素.  如果想有效地避免越界访问，可以使用 deque 模板类提供的 at() 成员函数, 如果想有效地避免越界访问，可以使用 deque 模板类提供的 at() 成员函数.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">d.front() &#x3D; 10;
d.back() &#x3D; 20;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="stl-list">STL list</h3>
<p>又称<code>双向链表容器</code>，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。每个元素都配备了 2 个指针，分别指向它的前一个元素和后一个元素。其中第一个元素的前向指针总为 null，因为它前面没有元素；同样，尾部元素的后向指针也总为 null。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/180912/2-1P912134314345.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>emplace_front()</td>
<td>在容器头部生成一个元素。该函数和 push_front() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_front()</td>
<td>在容器头部插入一个元素。</td>
</tr>
<tr>
<td>pop_front()</td>
<td>删除容器头部的一个元素。</td>
</tr>
<tr>
<td>emplace_back()</td>
<td>在容器尾部直接生成一个元素。该函数和 push_back() 的功能相同，但效率更高。</td>
</tr>
<tr>
<td>push_back()</td>
<td>在容器尾部插入一个元素。</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除容器尾部的一个元素。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在容器中的指定位置插入元素。该函数和 insert() 功能相同，但效率更高。</td>
</tr>
<tr>
<td>erase()</td>
<td>删除容器中一个或某区域内的元素。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换两个容器中的元素，必须保证这两个容器中存储的元素类型是相同的。</td>
</tr>
<tr>
<td>splice()</td>
<td>将一个 list 容器中的元素插入到另一个容器的指定位置。</td>
</tr>
<tr>
<td>remove(val)</td>
<td>删除容器中所有等于 val 的元素。</td>
</tr>
<tr>
<td>remove_if()</td>
<td>删除容器中满足条件的元素。</td>
</tr>
<tr>
<td>unique()</td>
<td>删除容器中相邻的重复元素，只保留一个。</td>
</tr>
<tr>
<td>merge()</td>
<td>合并两个事先已排好序的 list 容器，并且合并之后的 list 容器依然是有序的。</td>
</tr>
<tr>
<td>sort()</td>
<td>通过更改容器中元素的位置，将它们进行排序。</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转容器中元素的顺序。</td>
</tr>
</tbody>
</table>
<p>和 insert() 成员方法相比，splice() 成员方法的作用对象是其它 list 容器，其功能是将其它 list 容器中的元素添加到当前 list 容器中指定位置处。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 第一个参数是目标位置, 后面的参数是被移动对象
&#x2F;&#x2F;创建并初始化 2 个 list 容器
list&lt;int&gt; mylist1&#123; 1,2,3,4 &#125;, mylist2&#123;10,20,30&#125;;
list&lt;int&gt;::iterator it &#x3D; ++mylist1.begin(); &#x2F;&#x2F;指向 mylist1 容器中的元素 2
   
&#x2F;&#x2F;调用第一种语法格式
mylist1.splice(it, mylist2); &#x2F;&#x2F; mylist1: 1 10 20 30 2 3 4
                             &#x2F;&#x2F; mylist2:
                             &#x2F;&#x2F; it 迭代器仍然指向元素 2，只不过容器变为了 mylist1
&#x2F;&#x2F;调用第二种语法格式，将 it 指向的元素 2 移动到 mylist2.begin() 位置处
mylist2.splice(mylist2.begin(), mylist1, it);   &#x2F;&#x2F; mylist1: 1 10 20 30 3 4
                                                &#x2F;&#x2F; mylist2: 2
                                                &#x2F;&#x2F; it 仍然指向元素 2

&#x2F;&#x2F;调用第三种语法格式，将 [mylist1.begin(),mylist1.end())范围内的元素移动到 mylist.begin() 位置处                  
mylist2.splice(mylist2.begin(), mylist1, mylist1.begin(), mylist1.end());&#x2F;&#x2F;mylist1:
                                                                         &#x2F;&#x2F;mylist2:1 10 20 30 3 4 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="stl-forward-list">STL forward_list</h3>
<p>forward_list 是 C++ 11 新添加的一类容器，其底层实现和 list 容器一样，采用的也是链表结构，只不过 forward_list 使用的是单链表，而 list 使用的是双向链表.</p>
<p><img src="http://c.biancheng.net/uploads/allimg/191219/2-191219135239561.gif" alt="单链表和双向链表"></p>
<p>forward_list 容器中是不提供 size() 函数的，但如果想要获取 forward_list 容器中存储元素的个数，可以使用头文件 &lt;iterator&gt; 中的 <a href="http://c.biancheng.net/ref/tan.html">distance()</a> 函数。举个例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::forward_list&lt;int&gt; my_words&#123;1,2,3,4&#125;;
int count &#x3D; std::distance(std::begin(my_words), std::end(my_words));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>并且，forward_list 容器迭代器的移动除了使用 ++ 运算符单步移动，还能使用 advance() 函数.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 结果: 3,4
std::forward_list&lt;int&gt; values&#123;1,2,3,4&#125;;
auto it &#x3D; values.begin();
advance(it, 2);
while (it!&#x3D;values.end())
&#123;
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
    ++it;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="关联式容器">关联式容器</h2>
<p>关联式容器存储的是“键值对”形式的数据,  基于各个关联式容器存储数据的特点，只有各个键值对中的键和值全部对应相等时，才能使用 set 和 multiset 关联式容器存储，否则就要选用 map 或者 multimap 关联式容器。</p>
<h3 id="stl-pair">STL pair</h3>
<p>考虑到“键值对”并不是普通类型数据，<a href="http://c.biancheng.net/cplus/">C++</a> <a href="http://c.biancheng.net/stl/">STL</a> 标准库提供了 pair 类模板，其专门用来将 2 个普通元素 first 和 second. pair 类模板定义在<code>&lt;utility&gt;</code>头文件中.</p>
<p>下面程序演示了以上几种创建 pair 对象的方法:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 调用构造函数 1，也就是默认构造函数
pair &lt;string, double&gt; pair1;
&#x2F;&#x2F; 调用第 2 种构造函数
pair &lt;string, string&gt; pair2(&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;);  
&#x2F;&#x2F; 调用拷贝构造函数
pair &lt;string, string&gt; pair3(pair2);
&#x2F;&#x2F;调用移动构造函数
pair &lt;string, string&gt; pair4(make_pair(&quot;C++教程&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;));
&#x2F;&#x2F; 调用第 5 种构造函数
pair &lt;string, string&gt; pair5(string(&quot;Python教程&quot;), string(&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>&lt;utility&gt;</code>头文件中除了提供创建 pair 对象的方法之外，还为 pair 对象重载了 &lt;、&lt;=、&gt;、&gt;=、==、!= 这 6 的运算符，其运算规则是：对于进行比较的 2 个 pair 对象，先比较 pair.first 元素的大小，如果相等则继续比较 pair.second 元素的大小。(二维偏序)</p>
<p>最后需要指出的是，pair类模板还提供有一个 swap() 成员函数，能够互换 2 个 pair 对象的键值对，其操作成功的前提是这 2 个 pair 对象的键和值的类型要相同.</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair &lt;string, int&gt; pair1(&quot;pair&quot;, 10);                   
pair &lt;string, int&gt; pair2(&quot;pair2&quot;, 20);
&#x2F;&#x2F;交换 pair1 和 pair2 的键值对
pair1.swap(pair2);
&#x2F;&#x2F;pair1: pair2 20
&#x2F;&#x2F;pair2: pair 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="stl-map">STL map</h3>
<p>map 容器存储的都是 pair 对象，也就是用 pair 类模板创建的键值对。与此同时，在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序,  根据实际情况的需要，我们可以手动指定 map 容器的排序规则. <code>使用 map 容器存储的各个键值对，键的值既不能重复也不能被修改。</code>这意味着只要键值对被存储到 map 容器中，其键的值将不能再做任何修改。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;如下语句可以指定升序排列键值
std::map&lt;std::string, int, std::greater&lt;std::string&gt; &gt;myMap&#123; &#123;&quot;C语言教程&quot;,10&#125;,&#123;&quot;STL教程&quot;,20&#125; &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>find(key)</td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。另外，如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>lower_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>upper_bound(key)</td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。如果 map 容器用 const 限定，则该方法返回的是 const 类型的双向迭代器。</td>
</tr>
<tr>
<td>equal_range(key)</td>
<td>该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 pair.first 和 lower_bound() 方法的返回值等价，pair.second 和 upper_bound() 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 key 的键值对（map 容器键值对唯一，因此该范围最多包含一个键值对）。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
<tr>
<td>emplace_hint()</td>
<td>在本质上和 emplace() 在 map 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。</td>
</tr>
<tr>
<td>count(key)</td>
<td>在当前 map 容器中，查找键为 key 的键值对的个数并返回。注意，由于 map 容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 1。</td>
</tr>
</tbody>
</table>
<p><img src="http://c.biancheng.net/uploads/allimg/191128/2-19112Q14QE40.gif" alt="C++ STL map部分成员方法示意图"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建并初始化 map 容器
std::map&lt;std::string, std::string&gt;myMap&#123; &#123;&quot;STL教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;&#125;,
                                         &#123;&quot;C语言教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;&#125;,
                                         &#123;&quot;Java教程&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;&#125; &#125;;
&#x2F;&#x2F;找到第一个键的值不小于 &quot;Java教程&quot; 的键值对
auto iter &#x3D; myMap.lower_bound(&quot;Java教程&quot;);
&#x2F;&#x2F;lower：Java教程 http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;
cout &lt;&lt; &quot;lower：&quot; &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;

&#x2F;&#x2F;找到第一个键的值大于 &quot;Java教程&quot; 的键值对
iter &#x3D; myMap.upper_bound(&quot;Java教程&quot;);
&#x2F;&#x2F;upper：STL教程 http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;
cout &lt;&lt;&quot;upper：&quot; &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和 insert() 方法一样，虽然 emplace_hint() 方法指定了插入键值对的位置，但 map 容器为了保持存储键值对的有序状态，可能会移动其位置。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建并初始化 map 容器
std::map&lt;string, string&gt;mymap;
&#x2F;&#x2F;指定在 map 容器插入键值对
map&lt;string, string&gt;::iterator iter &#x3D; mymap.emplace_hint(mymap.begin(),&quot;STL教程&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;);
cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;
iter &#x3D; mymap.emplace_hint(mymap.begin(), &quot;C语言教程&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#x2F;&quot;);
cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;
&#x2F;&#x2F;插入失败样例
iter &#x3D; mymap.emplace_hint(mymap.begin(), &quot;STL教程&quot;, &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;);
cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只有当 map 容器中确实存有包含该指定键的键值对，借助重载的 [ ] 运算符才能成功获取该键对应的值；反之，若当前 map 容器中没有包含该指定键的键值对，则此时使用 [ ] 运算符将不再是访问容器中的元素，而变成了向该 map 容器中增添一个键值对。</p>
<h3 id="stl-multimap">STL multimap</h3>
<p>multimap 容器具有和 map 相同的特性，即 multimap 容器也用于存储 pair&lt;const K, T&gt; 类型的键值对（其中 K 表示键的类型，T 表示值的类型），其中各个键值对的键的值不能做修改；并且，该容器也会自行根据键的大小对存储的所有键值对做排序操作。<code>和 map 容器的区别在于，multimap 容器中可以同时存储多（≥2）个键相同的键值对。</code>和 map 容器一样，实现 multimap 容器的类模板也定义在<code>&lt;map&gt;</code>头文件，并位于 std 命名空间中。在某些特定场景中，我们还可以为 multimap 容器自定义排序规则. multimap的操作和成员函数基本与map完全一致. 但和 map 容器相比，<code>multimap 未提供 at() 成员方法，也没有重载 [] 运算符</code>。这意味着，map 容器中通过指定键获取指定指定键值对的方式，将不再适用于 multimap 容器。其实这很好理解，因为 multimap 容器中指定的键可能对应多个键值对，而不再是 1 个。另外，由于maltimap容器可存储多个具有相同键的键值对，因此lower_bound()、upper_bound()、equal_range()以及count()方法经常会用到。</p>
<h3 id="stl-set">STL set</h3>
<p>和 map、multimap 容器不同，使用 set 容器存储的各个键值对，要求键 key 和值 value 必须相等。基于 set 容器的这种特性，当使用 set 容器存储键值对时，只需要为其提供各键值对中的 value 值（也就是 key 的值）即可。set 容器也会自行根据键的大小对存储的键值对进行排序. <code>使用 set 容器存储的各个元素的值必须各不相同</code>。更重要的是，从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，<code>使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。</code></p>
<p><code>对于初学者来说，切勿尝试直接修改 set 容器中已存储元素的值，这很有可能破坏 set 容器中元素的有序性，最正确的修改 set 容器中元素值的做法是：先删除该元素，然后再添加一个修改后的元素。</code></p>
<p>set的成员函数和multimap基本一致, <code>set 容器类模板中未提供 at() 成员函数，也未对 [] 运算符进行重载。因此，要想访问 set 容器中存储的元素，只能借助 set 容器的迭代器。</code></p>
<p><code>C++ STL 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 p 为此类型的迭代器，则其只能进行 ++p、p++、--p、p--、*p 操作，并且 2 个双向迭代器之间做比较，也只能使用 == 或者 != 运算符。</code></p>
<p>如果只想遍历 set 容器中指定区域内的部分数据，则可以借助 find()、lower_bound() 以及 upper_bound() 实现。通过调用它们，可以获取一个指向指定元素的迭代器。equal_range(val) 函数的返回值是一个 pair 类型数据，其包含 2 个迭代器，表示 set 容器中和指定参数 val 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 2 个迭代器所表示的范围中，最多只会包含 1 个元素。</p>
<h3 id="stl-multiset">STL multiset</h3>
<p>和 set 容器不同的是，<code>multiset 容器可以存储多个值相同的元素。</code>虽然 multiset 容器和 set 容器拥有的成员方法完全相同，但由于 multiset 容器允许存储多个值相同的元素，因此诸如 count()、find()、lower_bound()、upper_bound()、equal_range()等方法，更常用于 multiset 容器。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::multiset&lt;int&gt; mymultiset&#123;1,2,2,2,3,4,5&#125;;
&#x2F;&#x2F;multiset size &#x3D; 7
cout &lt;&lt; &quot;multiset size &#x3D; &quot; &lt;&lt; mymultiset.size() &lt;&lt; endl;
&#x2F;&#x2F;multiset count(2) &#x3D;3
cout &lt;&lt; &quot;multiset count(2) &#x3D;&quot; &lt;&lt; mymultiset.count(2) &lt;&lt; endl;
&#x2F;&#x2F;向容器中添加元素 8
mymultiset.insert(8);
&#x2F;&#x2F;删除容器中所有值为 2 的元素
int num &#x3D; mymultiset.erase(2);
&#x2F;&#x2F;删除了 3 个元素 2
cout &lt;&lt; &quot;删除了 &quot; &lt;&lt; num &lt;&lt; &quot; 个元素 2&quot; &lt;&lt; endl;
&#x2F;&#x2F;输出容器中存储的所有元素 1 3 4 5 8
for (auto iter &#x3D; mymultiset.begin(); iter !&#x3D; mymultiset.end(); ++iter) &#123;
    cout &lt;&lt; *iter &lt;&lt; &quot; &quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="关联式容器自定义排序">关联式容器自定义排序</h3>
<p>模板库中常用的可供关联容器使用的排序规则为<img src="https://img-blog.csdnimg.cn/20210422104233471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDQ4NDcxNQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>同时也可以自定义:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class cmp &#123;
public:
    &#x2F;&#x2F;重载 () 运算符
    bool operator ()(const string &amp;a,const string &amp;b) &#123;
        &#x2F;&#x2F;按照字符串的长度，做升序排序(即存储的字符串从短到长)
        return  (a.length() &lt; b.length());
    &#125;
&#125;;
int main() &#123;
    &#x2F;&#x2F;创建 set 容器，并使用自定义的 cmp 排序规则
    std::set&lt;string, cmp&gt;myset&#123;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;&quot;,
                               &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;,
                               &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;&quot;&#125;;
    &#x2F;&#x2F;输出容器中存储的元素
    for (auto iter &#x3D; myset.begin(); iter !&#x3D; myset.end(); ++iter) &#123;
            cout &lt;&lt; *iter &lt;&lt; endl;
    &#125;
    return 0;
&#125;
&#x2F;&#x2F;结果：
&#x2F;&#x2F;http:&#x2F;&#x2F;c.biancheng.net&#x2F;stl&#x2F;
&#x2F;&#x2F;http:&#x2F;&#x2F;c.biancheng.net&#x2F;java&#x2F;
&#x2F;&#x2F;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当关联式容器中存储的数据类型为自定义的结构体变量或者类对象时，通过对现有排序规则中所用的关系运算符进行重载，也能实现自定义排序规则的目的。注意，当关联式容器中存储的元素类型为结构体指针变量或者类的指针对象时，只能使用函数对象的方式自定义排序规则，此方法不再适用。</p>
<h2 id="无序关联式容器">无序关联式容器</h2>
<p>无序关联式容器，又称哈希容器。和关联式容器一样，此类容器存储的也是键值对元素；不同之处在于，关联式容器默认情况下会对存储的元素做升序排序，而无序关联式容器不会。<code>无序关联式容器擅长通过指定键查找对应的值，而遍历容器中存储元素的效率不如关联式容器。</code></p>
<p><strong>关联式容器的底层实现采用的树存储结构，更确切的说是红黑树结构；无序容器的底层实现采用的是哈希表的存储结构, 并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”。</strong></p>
<p>基于底层实现采用了不同的数据结构，因此和关联式容器相比，无序容器具有以下 2 个特点：</p>
<ol>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li>
</ol>
<table>
<thead>
<tr>
<th>无序容器</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>unordered_map</td>
<td>存储键值对 &lt;key, value&gt; 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td>unordered_set</td>
<td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody>
</table>
<h3 id="unordered-map">unordered_map</h3>
<p>unordered_map 定义在<code>&lt;unordered_map&gt;</code>头文件</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>bucket_count()</td>
<td>返回当前容器底层存储键值对时，使用桶（一个线性链表代表一个桶）的数量。</td>
</tr>
<tr>
<td>max_bucket_count()</td>
<td>返回当前系统中，unordered_map 容器底层最多可以使用多少桶。</td>
</tr>
<tr>
<td>bucket_size(n)</td>
<td>返回第 n 个桶中存储键值对的数量。</td>
</tr>
<tr>
<td>bucket(key)</td>
<td>返回以 key 为键的键值对所在桶的编号。</td>
</tr>
<tr>
<td>load_factor()</td>
<td>返回 unordered_map 容器中当前的负载因子。负载因子，指的是的当前容器中存储键值对的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td>
</tr>
<tr>
<td>max_load_factor()</td>
<td>返回或者设置当前 unordered_map 容器的负载因子。</td>
</tr>
<tr>
<td>rehash(n)</td>
<td>将当前容器底层使用桶的数量设置为 n。</td>
</tr>
<tr>
<td>reserve()</td>
<td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳count个元（不超过最大负载因子）所需的数量，并重新整理容器。</td>
</tr>
<tr>
<td>hash_function()</td>
<td>返回当前容器使用的哈希函数对象。</td>
</tr>
</tbody>
</table>
<p>unordered_map 容器类模板中，实现了对 [ ] 运算符的重载，使得我们可以像“利用下标访问普通数组中元素”那样，通过目标键值对的键获取到该键对应的值。如果当前容器中并没有存储以 [ ] 运算符内指定的元素作为键的键值对，则此时 [ ] 运算符的功能将转变为：向当前容器中添加以目标元素为键的键值对.</p>
<h3 id="stl-unordered-multimap">STL unordered_multimap</h3>
<p>unordered_multimap 容器可以存储多个键相等的键值对，而 unordered_map 容器不行。</p>
<h3 id="stl-unordered-set">STL unordered_set</h3>
<p>unordered_set 容器，可直译为“无序 set 容器”，即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。实现 unordered_set 容器的模板类定义在&lt;unordered_set&gt;头文件</p>
<p><strong>总的来说，unordered_set 容器具有以下几个特性：</strong></p>
<ol>
<li><strong>不再以键值对的形式存储数据，而是直接存储数据的值；</strong></li>
<li><strong>容器内部存储的各个元素的值都互不相等，且不能被修改。</strong></li>
<li><strong>不会对内部存储的数据进行排序</strong></li>
</ol>
<h3 id="stl-unordered-multiset">STL unordered_multiset</h3>
<p>和 unordered_set 容器不同的是，unordered_multiset 容器可以同时存储多个值相同的元素，且这些元素会存储到哈希表中同一个桶（本质就是链表）上。</p>
<h2 id="容器适配器">容器适配器</h2>
<p>STL 提供了 3 种容器适配器，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。</p>
<table>
<thead>
<tr>
<th>容器适配器</th>
<th>基础容器筛选条件</th>
<th>默认使用的基础容器</th>
</tr>
</thead>
<tbody>
<tr>
<td>stack</td>
<td>基础容器需包含以下成员函数：empty()size()back()push_back()pop_back()满足条件的基础容器有 vector、deque、list。</td>
<td>deque</td>
</tr>
<tr>
<td>queue</td>
<td>基础容器需包含以下成员函数：empty()size()front()back()push_back()pop_front()满足条件的基础容器有 deque、list。</td>
<td>deque</td>
</tr>
<tr>
<td>priority_queue</td>
<td>基础容器需包含以下成员函数：empty()size()front()push_back()pop_back()满足条件的基础容器有vector、deque。</td>
<td>vector</td>
</tr>
</tbody>
</table>
<h3 id="stl-stack">STL stack</h3>
<p>stack 栈适配器是一种单端开口的容器（如图 1 所示），实际上该容器模拟的就是栈存储结构，即无论是向里存数据还是从中取数据，都只能从这一个开口实现操作。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/180913/2-1P913101Q4T2.jpg" alt="stack适配器示意图"></p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>当 stack 栈中没有元素时，该成员函数返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回 stack 栈中存储元素的个数。</td>
</tr>
<tr>
<td>top()</td>
<td>返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td>
</tr>
<tr>
<td>push(const T&amp; val)</td>
<td>先复制 val，再将 val 副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</td>
</tr>
<tr>
<td>push(T&amp;&amp; obj)</td>
<td>以移动元素的方式将其压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</td>
</tr>
<tr>
<td>pop()</td>
<td>弹出栈顶元素。</td>
</tr>
<tr>
<td>emplace(arg…)</td>
<td>arg… 可以是一个参数，也可以是多个参数，但它们都只用于构造一个对象，并在栈顶直接生成该对象，作为新的栈顶元素。</td>
</tr>
<tr>
<td>swap(stack<T> &amp; other_stack)</T></td>
<td>将两个 stack 适配器中的元素进行互换，需要注意的是，进行互换的 2 个 stack 适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody>
</table>
<h3 id="stl-queue">STL queue</h3>
<p>queue 容器适配器有 2 个开口，其中一个开口专门用来输入数据，另一个专门用来输出数据</p>
<p><img src="http://c.biancheng.net/uploads/allimg/180913/2-1P913113140553.jpg" alt="queue容器适配器"></p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>如果 queue 中没有元素的话，返回 true。</td>
</tr>
<tr>
<td>size()</td>
<td>返回 queue 中元素的个数。</td>
</tr>
<tr>
<td>front()</td>
<td>返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td>
</tr>
<tr>
<td>back()</td>
<td>返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。</td>
</tr>
<tr>
<td>push(const T&amp; obj)</td>
<td>在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。</td>
</tr>
<tr>
<td>emplace()</td>
<td>在 queue 的尾部直接添加一个元素。</td>
</tr>
<tr>
<td>push(T&amp;&amp; obj)</td>
<td>以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除 queue 中的第一个元素。</td>
</tr>
<tr>
<td>swap(queue<T> &amp;other_queue)</T></td>
<td>将两个 queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody>
</table>
<p><code>和 stack 一样，queue 也没有迭代器，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。</code></p>
<h3 id="stl-priority-queue">STL priority_queue</h3>
<p>priority_queue 容器适配器模拟的也是队列这种存储结构，即使用此容器适配器存储元素只能“从一端进（称为队尾），从另一端出（称为队头）”，且每次只能访问 priority_queue 中位于队头的元素。但是，priority_queue 容器适配器中元素的存和取，遵循的并不是 “First in,First out”（先入先出）原则，而是“First in，Largest out”原则。直白的翻译，指的就是先进队列的元素并不一定先出队列，而是优先级最大的元素最先出队列。使用<code>std::less&lt;T&gt;</code>按照元素值从大到小进行排序，还可以使用<code>std::greater&lt;T&gt;</code>按照元素值从小到大排序，但更多情况下是使用自定义的排序规则。 priority_queue 容器适配器模板位于<code>&lt;queue&gt;</code>头文件中.</p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty()</td>
<td>如果 priority_queue 为空的话，返回 true；反之，返回 false。</td>
</tr>
<tr>
<td>size()</td>
<td>返回 priority_queue 中存储元素的个数。</td>
</tr>
<tr>
<td>top()</td>
<td>返回 priority_queue 中第一个元素的引用形式。</td>
</tr>
<tr>
<td>push(const T&amp; obj)</td>
<td>根据既定的排序规则，将元素 obj 的副本存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td>push(T&amp;&amp; obj)</td>
<td>根据既定的排序规则，将元素 obj 移动存储到 priority_queue 中适当的位置。</td>
</tr>
<tr>
<td>emplace(Args&amp;&amp;… args)</td>
<td>Args&amp;&amp;… args 表示构造一个存储类型的元素所需要的数据（对于类对象来说，可能需要多个数据构造出一个对象）。此函数的功能是根据既定的排序规则，在容器适配器适当的位置直接生成该新元素。</td>
</tr>
<tr>
<td>pop()</td>
<td>移除 priority_queue 容器适配器中第一个元素。</td>
</tr>
<tr>
<td>swap(priority_queue<T>&amp; other)</T></td>
<td>将两个 priority_queue 容器适配器中的元素进行互换，需要注意的是，进行互换的 2 个 priority_queue 容器适配器中存储的元素类型以及底层采用的基础容器类型，都必须相同。</td>
</tr>
</tbody>
</table>
<p>优先级队列默认<strong>使用vector作为其底层存储数据</strong>的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue就是堆，所有需要用到堆的位置，都可以考虑使用priority_queue。</p>
]]></content>
      <categories>
        <category>清浅集</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>stl</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch多Stream管理</title>
    <url>//post/Pytorch%E5%A4%9AStream%E7%AE%A1%E7%90%86.html</url>
    <content><![CDATA[<p>import shutil</p>
<p>import torch</p>
<p>import torch.nn as nn</p>
<p>import torch.nn.functional as F</p>
<p>class ModelBaseline(nn.Module):</p>
<p>​    def <strong>init</strong>(self, d, n=4):</p>
<p>​        super().<strong>init</strong>()</p>
<p>​        self.norm = nn.LayerNorm(d)</p>
<p>​        self.linear1 = nn.Linear(d, d * n)</p>
<p>​        self.linear2 = nn.Linear(d * 4, d)</p>
<p>​        self.offload_stream = torch.cuda.Stream()</p>
<p>​    def forward(self, src: torch.Tensor):</p>
<p>​        x = self.norm(src)</p>
<p>​        src = <a href="http://src.to">src.to</a>(device=‘cpu’, non_blocking=True)</p>
<p>​        x = self.linear2(F.relu(self.linear1(x)))</p>
<p>​        src = <a href="http://src.to">src.to</a>(device=‘cuda’, non_blocking=True)</p>
<p>​        return src + x</p>
<p>class ModelWaitStream(nn.Module):</p>
<p>​    def <strong>init</strong>(self, d, n=4):</p>
<p>​        super().<strong>init</strong>()</p>
<p>​        self.norm = nn.LayerNorm(d)</p>
<p>​        self.linear1 = nn.Linear(d, d * n)</p>
<p>​        self.linear2 = nn.Linear(d * 4, d)</p>
<p>​        self.offload_stream = torch.cuda.Stream()</p>
<p>​    def forward(self, src: torch.Tensor):</p>
<p>​        x = self.norm(src)</p>
<p>​        self.offload_stream.wait_stream(torch.cuda.current_stream())</p>
<p>​        with torch.cuda.stream(self.offload_stream):</p>
<p>​            src = <a href="http://src.to">src.to</a>(device=‘cpu’, non_blocking=True)</p>
<p>​        x = self.linear2(F.relu(self.linear1(x)))</p>
<p>​        with torch.cuda.stream(self.offload_stream):</p>
<p>​            src = <a href="http://src.to">src.to</a>(device=‘cuda’, non_blocking=True)</p>
<p>​            evt_2 = self.offload_stream.record_event()</p>
<p>​        torch.cuda.current_stream().wait_stream(self.offload_stream)</p>
<p>​        return src + x</p>
<p>class ModelWaitEvent(nn.Module):</p>
<p>​    def <strong>init</strong>(self, d, n=4):</p>
<p>​        super().<strong>init</strong>()</p>
<p>​        self.norm = nn.LayerNorm(d)</p>
<p>​        self.linear1 = nn.Linear(d, d * n)</p>
<p>​        self.linear2 = nn.Linear(d * 4, d)</p>
<p>​        self.offload_stream = torch.cuda.Stream()</p>
<p>​    def forward(self, src: torch.Tensor):</p>
<p>​        x = self.norm(src)</p>
<p>​        evt_1 = torch.cuda.current_stream().record_event()</p>
<p>​        with torch.cuda.stream(self.offload_stream):</p>
<p>​            self.offload_stream.wait_event(evt_1)</p>
<p>​            src = <a href="http://src.to">src.to</a>(device=‘cpu’, non_blocking=True)</p>
<p>​        x = self.linear2(F.relu(self.linear1(x)))</p>
<p>​        with torch.cuda.stream(self.offload_stream):</p>
<p>​            src = <a href="http://src.to">src.to</a>(device=‘cuda’, non_blocking=True)</p>
<p>​            evt_2 = self.offload_stream.record_event()</p>
<p>​        torch.cuda.current_stream().wait_event(evt_2)</p>
<p>​        return src + x</p>
]]></content>
  </entry>
  <entry>
    <title>源码编译pytorch踩坑记录</title>
    <url>//post/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91pytorch%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html</url>
    <content><![CDATA[<h1>源码编译Pytorch踩坑记录</h1>
<h3 id="获取pytorch源码">获取pytorch源码</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">conda <span class="token function">install</span> mkl mkl-include
<span class="token comment"># CUDA only: Add LAPACK support for the GPU if needed</span>
conda <span class="token function">install</span> <span class="token parameter variable">-c</span> pytorch magma-cuda113  <span class="token comment"># or the magma-cuda* that matches your CUDA version from https://anaconda.org/pytorch/repo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这一步都还没有什么问题, 接下来按照官网的指南执行</p>
<h3 id="install-pytorch">Install Pytorch</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">CMAKE_PREFIX_PATH</span><span class="token operator">=</span><span class="token variable">$&#123;CONDA_PREFIX<span class="token operator">:-</span>"$(dirname $(which conda))<span class="token operator">/</span>..<span class="token operator">/</span>"&#125;</span>
python setup.py develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>开始报错</p>
<h4 id="error-inlining-failed-in-call-to-always-inline-mm256-set1-ps-target-specific-option-mismatch">error: inlining failed in call to always_inline ‘_mm256_set1_ps’: target specific option mismatch</h4>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-mfma"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重新编译一遍发现这个错误不见了, 但是类似的还在,如<code>error: inlining failed in call to always_inline ‘_mm256_abs_epi16’: target specific option mismatch</code>. 所以感觉这个问题不是根本问题, 继续检索错误文件, 发现了这个问题<code>cc: error: /arch:AVX512: No such file or directory</code>.感觉这个地方才是本质问题, 所以先看这里, 参考<a href="https://stackoverflow.com/questions/57043592/compilation-error-for-avx512-is-it-a-gcc-issue">这篇文章</a>, 尝试以下指令</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-mavx512f"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重新编译发现错误变少了, 但是<code>cc: error: /arch:AVX512: No such file or directory</code>这个报错还在</p>
<p>尝试了很多方法都不行, 最后查了一下, 应该是电脑不支持avx512指令集, 可以用<code>cat /proc/cpuinfo | grep avx512</code>指令查看一下, 我的电脑上没有, 所以一直报错. 在set.py文件里可以看到这样的一段话</p>
<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot="">
<path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path>
<path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path>
<path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path>
<path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path>
</svg>
</span><p>ATEN_AVX512_256=TRUE<br>
ATen AVX2 kernels can use 32 ymm registers, instead of the default 16.<br>
This option can be used if AVX512 doesn’t perform well on a machine.<br>
The FBGEMM library also uses AVX512_256 kernels on Xeon D processors,<br>
but it also has some (optimized) assembly code.</p></blockquote>
<p>把这个环境变量改成false试了一下好像也不行, 最后无奈换了个设备重新编译</p>
<h3 id="error-use-of-fmt-before-deduction-of-auto">error: use of ‘fmt::…’ before deduction of ‘auto’</h3>
<p><img src="/post/image-20230307102419154.png" alt="image-20230307102419154"></p>
<p>在新的设备上构建cmakelists的时候没有什么问题, 但是编译的时候一直报这个错. 看路径是third_party里面的fmt这个包的问题, 但是我进入到这个包目录下cmake, make, make install 都是没有问题的.</p>
<p>最后是因为编译器版本的问题, 给gcc升级从6.5.0到8.4.0就可以了.</p>
<h3 id="终极解决方案">终极解决方案</h3>
<p>中间还经历了各种奇奇怪怪的问题, 但是最后都是用这个方法一下子解决的. 看到github上有人和我遇到了同样问题, 最后是重新fetch最新代码解决的, 我就也重新fetch了一下, 然后代码直接覆盖掉了之前的所有更改, 什么都不用做就全部编译通过了. 所以记录一下, 以后遇到类似的问题记得先检查<code>git clone --recursive</code>有没有成功, 之后一定要确保是最新的代码.</p>
]]></content>
      <categories>
        <category>清浅集</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
</search>
