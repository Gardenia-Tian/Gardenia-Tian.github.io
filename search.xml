<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Optimize Cache</title>
    <url>//post/Optimize-Cache.html</url>
    <content><![CDATA[<h1 id="缓存优化方案"><a href="#缓存优化方案" class="headerlink" title="缓存优化方案"></a>缓存优化方案</h1><p>这里总结一些现有的缓存优化方案, 当然还有很多其他的方案, 这里聚焦在我所不熟悉的部分.</p>
<h2 id="Pipelined-caches"><a href="#Pipelined-caches" class="headerlink" title="Pipelined caches"></a>Pipelined caches</h2><p>实现缓存访问的流水化, 使第一级缓存命中的实际延迟可以分散到多个时钟周期, 从而缩短时钟周期时间, 提高带宽, 但会减缓命中速度. </p>
<h2 id="Multibanked-caches"><a href="#Multibanked-caches" class="headerlink" title="Multibanked caches"></a>Multibanked caches</h2><p>将缓存划分成几个相互独立, 支持同时访问的缓存组.</p>
<h2 id="Merging-write-buffers"><a href="#Merging-write-buffers" class="headerlink" title="Merging write buffers"></a>Merging write buffers</h2><p>合并写缓冲区以降低缺失代价, 因为所有存储内容都必须发送到层次结构的下一层次, 所以直写缓存依赖于写缓冲区. 如果写缓冲区为空, 则数据和整个地址被写到缓冲区中, 从处理器的角度来看, 写入操作已经完成. 如果缓冲区中包含其他经过修改的块, 则检查它们的地址, 看新数据的地址是否与写缓冲区中有效项目地址匹配. 如果匹配, 则将新数据与这个项目合并在一起, 这种优化方法成为写合并.</p>
<h2 id="Hardware-Prefetching"><a href="#Hardware-Prefetching" class="headerlink" title="Hardware Prefetching"></a>Hardware Prefetching</h2><p>在处理器请求项目之前, 预先提取它们. 指令和数据都可以预取. 指令预取通常在缓存外部的硬件中完成, </p>
<h2 id="Compiler-optimizations"><a href="#Compiler-optimizations" class="headerlink" title="Compiler optimizations"></a>Compiler optimizations</h2><p>这种技术可以在不改变任何硬件的情况下降低缺失率. 主要分成两个维度: 指令缺失性能改进和数据缺失性能改进.</p>
<ol>
<li>循环交换: 数据的连续性</li>
<li>分块: 对于正交访问模式, 可以对子矩阵进行操作.其目的是在缓存中载入的数据被替换之前, 在最大限度上利用它.</li>
</ol>
<p>编译器优化还可以用来控制预取, 以降低缺失代价或缺失率</p>
<p>作为硬件预取的替代方案, 可以在处理器需要某一数据之前, 由编译器插入请求该数据的预取指令:</p>
<ol>
<li>寄存器预取将数据值载入到一个寄存器中</li>
<li>缓存预取仅将数据载入到缓存中, 而不是寄存器中</li>
</ol>
]]></content>
      <categories>
        <category>清浅录</category>
      </categories>
      <tags>
        <tag>课程</tag>
        <tag>体系结构</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>//post/%E5%90%AF%E7%A8%8B.html</url>
    <content><![CDATA[<h1 id="年轻人的第一篇博客"><a href="#年轻人的第一篇博客" class="headerlink" title="年轻人的第一篇博客"></a>年轻人的第一篇博客</h1><p>GitHub的博客仓库很早就创立了, 但是拖了很久都没有部署. 总是因为各种原因退缩, 这次终于把界面什么的都配置了一下, 算是勉勉强强能看了, 还有很多功能还没有开发, 这些还需要日后一点一点探索, 不过有了GitHub博客也终于向一名合格的程序员迈进了一步, 希望以后能在这里记录一下自己的学习笔记, 日常心得, 生活碎片, 也希望能给浏览到博客的朋友带来一点点帮助.</p>
<p><img src="/post/%E5%90%AF%E7%A8%8B/1.jpg"></p>
]]></content>
      <categories>
        <category>陶然集</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Reproducibility Badges</title>
    <url>//post/Reproducibility-Badges.html</url>
    <content><![CDATA[<h1>Reproducibility Badges</h1>
<p>最近SC22正在如火如荼地进行, 作为一个科研小白, 我也有简单地远程围观这次会议. 在阅读SC会议的论文的时候, 我们会发现论文上总是有三个圆形的小标志, 所以不禁好奇这个是个什么东西, 经过一番查阅资料这里简单一下这个标志的含义.</p>
<p><img src="/post/1.png" alt></p>
<p>这三个标志是Reproducibility Badges, 也就是再现性徽章.</p>
]]></content>
      <categories>
        <category>清浅集</category>
      </categories>
      <tags>
        <tag>conference</tag>
        <tag>SC</tag>
      </tags>
  </entry>
</search>
